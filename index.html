<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Grow Garden TMA</title>
  
  <!-- Telegram Web App SDK -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  
  <!-- React CDN -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  
  <!-- Babel for JSX in browser -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Tailwind CSS for styling -->
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    :root { color-scheme: light dark; }
    html, body, #root { height: 100%; margin: 0; padding: 0; }
    body {
      background: var(--tg-theme-bg-color, #f1f5f1);
      color: var(--tg-theme-text-color, #000);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      overflow: auto; /* –ù–ï –∑–∞–ø—Ä–µ—â–∞–µ–º —Å–∫—Ä–æ–ª–ª */
    }

    /* –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è */
    .app-container{
      height: 100svh;
      max-width: 540px;
      width: min(100vw, 540px);
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      padding-left: max(12px, env(safe-area-inset-left));
      padding-right: max(12px, env(safe-area-inset-right));
      padding-bottom: env(safe-area-inset-bottom);
      box-sizing: border-box;
    }

    /* –í–µ—Ä—Ö–Ω—è—è –∏–≥—Ä–æ–≤–∞—è –∑–æ–Ω–∞ */
    .play-area{
      border-radius: 16px 16px 24px 24px;
      box-shadow: 0 6px 20px rgba(0,0,0,.12);
      display:flex; align-items:center; justify-content:center;
      padding: 12px 14px;
    }

    /* –ì—Ä—è–¥–∫–∏ */
    .plots{
      width: 100%;
      max-width: min(92vw, 500px);
      margin: 0 auto;
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 10px;
    }
    /* –ê–¥–∞–ø—Ç–∞—Ü–∏—è –¥–ª—è —É–∑–∫–∏—Ö —ç–∫—Ä–∞–Ω–æ–≤ */
    @media (max-width: 360px){
      .plots{ grid-template-columns: repeat(2, minmax(0, 1fr)); }
    }

    /* –Ø—á–µ–π–∫–∞ –≥—Ä—è–¥–∫–∏ */
    .plot{
      position: relative;
      aspect-ratio: 1 / 1;
      border-radius: 12px;
      border: 2px solid #6a4d1c;
      background: rgba(155, 118, 47, .8);
      display:flex; align-items:center; justify-content:center;
    }

    /* –ù–∏–∂–Ω—è—è –ø–∞–Ω–µ–ª—å */
    .bottom-panel{
      height: clamp(220px, 34svh, 320px);
      display:flex; flex-direction:column;
    }
    .panel-scroll{
      flex: 1 1 auto;
      overflow: auto;
      scrollbar-width: thin;
    }
    .panel-scroll::-webkit-scrollbar{ width:4px; }
    .panel-scroll::-webkit-scrollbar-thumb{ background: rgba(0,0,0,.2); border-radius: 2px; }

    /* –¢–æ—Å—Ç */
    .toast{
      position: fixed;
      top: max(8px, calc(env(safe-area-inset-top) + 8px));
      left: 50%; transform: translateX(-50%);
      z-index: 50;
    }

    /* –¢–∞–π–º–µ—Ä —ç–Ω–µ—Ä–≥–∏–∏ */
    .energy-timer{ font-size: 10px; line-height: 1; opacity: .85; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useCallback } = React;
    
    // --- TELEGRAM WEB APP INTEGRATION ---
    const tg = window.Telegram?.WebApp;

    if (tg) {
      tg.ready();
      tg.expand();
      tg.setHeaderColor('bg_color');
      tg.setBackgroundColor('bg_color');
    }

    function applyTheme() {
      const p = tg?.themeParams || {};
      document.documentElement.style.setProperty('--tg-theme-bg-color', p.bg_color || '#f1f5f1');
      document.documentElement.style.setProperty('--tg-theme-text-color', p.text_color || '#000000');
    }
    applyTheme();
    tg?.onEvent('themeChanged', applyTheme);

    function haptic(kind) {
      try {
        if (!tg?.HapticFeedback) return;
        if (kind === 'success') tg.HapticFeedback.notificationOccurred('success');
        else if (kind === 'error') tg.HapticFeedback.notificationOccurred('error');
        else tg.HapticFeedback.impactOccurred('light');
      } catch {}
    }

    const tgUserId = (tg && tg.initDataUnsafe?.user?.id) ? String(tg.initDataUnsafe.user.id) : 'dev';
    const SAVE_KEY = `growGardenState:${tgUserId}`;

    // --- GAME CODE STARTS HERE ---
    
    // --- –£–¢–ò–õ–ò–¢–´ ---
    const Ticks = { GAME: 1000, WEATHER: 15 * 60 * 1000, MARKET: 5 * 60 * 1000, ORDERS: 10 * 60 * 1000 };
    const OFFLINE_CAP_HOURS = 3;
    const clamp = (num, min, max) => Math.min(Math.max(num, min), max);
    const formatTime = (seconds) => {
        if (seconds < 0) return '0:00';
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
    };
    const fmtMMSS = (totalSec) => {
      const m = Math.floor(totalSec / 60);
      const s = totalSec % 60;
      return `${m}:${s < 10 ? '0' : ''}${s}`;
    };
    function energySecondsToNext(energy, now) {
      if (energy.current >= energy.max) return 0;
      const intervalMs = 60000 / Math.max(0.0001, energy.regenPerMinute);
      const msPassedSinceLastRegen = now - energy.lastRefill;
      const msLeft = intervalMs - (msPassedSinceLastRegen % intervalMs);
      return Math.ceil(msLeft / 1000);
    }

    // --- –ò–ì–†–û–í–´–ï –ö–û–ù–°–¢–ê–ù–¢–´ –ò –ë–ê–õ–ê–ù–° ---
    const CROP_DATA = {
        Carrot: { name: '–ú–æ—Ä–∫–æ–≤—å', icon: 'ü•ï', growTime: 30, basePrice: 4, seedPrice: 5, baseYield: 2, qualityPerTick: 0.003, decayWater: 0.4, decayFert: 0.15 },
        Tomato: { name: '–ü–æ–º–∏–¥–æ—Ä', icon: 'üçÖ', growTime: 60, basePrice: 7, seedPrice: 8, baseYield: 3, qualityPerTick: 0.004, decayWater: 0.5, decayFert: 0.18 },
        Sunflower: { name: '–ü–æ–¥—Å–æ–ª–Ω—É—Ö', icon: 'üåª', growTime: 90, basePrice: 10, seedPrice: 12, baseYield: 1, qualityPerTick: 0.005, decayWater: 0.6, decayFert: 0.20 },
        Herb: { name: '–¢—Ä–∞–≤—ã', icon: 'üåø', growTime: 45, basePrice: 5, seedPrice: 6, baseYield: 4, qualityPerTick: 0.002, decayWater: 0.3, decayFert: 0.12 },
    };
    const UPGRADE_DATA = {
        EnergyCap: { name: '–ú–∞–∫—Å. —ç–Ω–µ—Ä–≥–∏—è', baseCost: 20, costScale: 10, effect: (lvl) => `+5 –ú–∞–∫—Å. ‚ö°` },
        Storage: { name: '–°–∫–ª–∞–¥', baseCost: 25, costScale: 15, effect: (lvl) => `+20 –≤–º–µ—Å—Ç.` },
        EnergyRegen: { name: '–†–µ–≥–µ–Ω. —ç–Ω–µ—Ä–≥–∏–∏', baseCost: 30, costScale: 15, effect: (lvl) => `+0.5 ‚ö°/–º–∏–Ω` },
    }

    // --- –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ---
    const calculateYield = (crop) => {
        const cropData = CROP_DATA[crop.type];
        return Math.max(1, Math.round(cropData.baseYield * (0.8 + 0.2 * crop.quality)));
    };

    const createInitialState = () => ({
      plots: Array.from({ length: 6 }, (_, i) => ({ id: `plot-${i}` })),
      inv: { seeds: { Carrot: 10, Tomato: 5, Sunflower: 0, Herb: 5 }, raw: {}, products: {}, items: { Fertilizer: 5, PestControl: 0 } },
      buildings: { juicer: { level: 0 }, oilPress: { level: 0 }, dryer: { level: 0 }, beehive: { level: 0, stored: 0, lastTick: Date.now() }, sprinkler: { level: 0, targets: [] }, composter: { level: 0 }, storage: { level: 1, capacity: 50 } },
      orders: [],
      eco: {
        coins: 50, gems: 0,
        energy: { current: 20, max: 20, lastRefill: Date.now(), regenPerMinute: 1 },
        marketTrend: { Carrot: 1, Tomato: 1, Sunflower: 1, Herb: 1 },
        lastMarketUpdate: Date.now()
      },
      world: { weather: 'Sunny', event: 'None', lastWeatherUpdate: Date.now(), lastEventUpdate: Date.now(), lastOrdersUpdate: Date.now() },
      streak: { day: 0, lastClaim: 0 },
      achievements: { 'harvest_carrot_1': { name: '–°–æ–±—Ä–∞—Ç—å 100 –º–æ—Ä–∫–æ–≤–æ–∫', progress: 0, goal: 100, claimed: false, reward: '100 coins' }, 'complete_orders_1': { name: '–í—ã–ø–æ–ª–Ω–∏—Ç—å 10 –∑–∞–∫–∞–∑–æ–≤', progress: 0, goal: 10, claimed: false, reward: '5 gems' } },
      lastActiveAt: Date.now(),
      upgrades: { EnergyCap: 0, Storage: 0, EnergyRegen: 0 },
    });

    const generateOrders = (count) => {
        return Array.from({ length: count }, (_, i) => {
            const reqItem1 = Object.keys(CROP_DATA)[Math.floor(Math.random() * 4)]; 
            const reqQty1 = 5 + Math.floor(Math.random() * 10);
            const reward = Math.floor(CROP_DATA[reqItem1].basePrice * reqQty1 * (1.5 + Math.random() * 0.5));
            return { id: `order-${Date.now()}-${i}`, requires: [{ item: reqItem1, qty: reqQty1 }], rewardCoins: reward, rewardGems: Math.random() < 0.1 ? 1 : undefined, expiresAt: Date.now() + 15 * 60 * 1000 };
        });
    };

    // --- –û–°–ù–û–í–ù–û–ô –ö–û–ú–ü–û–ù–ï–ù–¢ ---
    function App() {
      const [gameState, setGameState] = useState(() => {
        try {
          const saved = localStorage.getItem(SAVE_KEY);
          let state = saved ? JSON.parse(saved) : createInitialState();
          
          if (!state.upgrades) state.upgrades = { EnergyCap: 0, Storage: 0, EnergyRegen: 0 };
          if (state.eco.energy.regenPerMinute === undefined) state.eco.energy.regenPerMinute = 1;

          const now = Date.now();
          const dt = Math.min(now - state.lastActiveAt, OFFLINE_CAP_HOURS * 3600 * 1000);
          const energyGained = Math.floor(dt / 60000 * state.eco.energy.regenPerMinute);
          if (energyGained > 0) {
            state.eco.energy.current = Math.min(state.eco.energy.max, state.eco.energy.current + energyGained);
            state.eco.energy.lastRefill = now;
          }
          state.lastActiveAt = now;
          return state;
        } catch { return createInitialState(); }
      });
      
      const [activeTab, setActiveTab] = useState('Plant');
      const [selectedSeed, setSelectedSeed] = useState('Carrot');
      const [toast, setToast] = useState(null);
      const [now, setNow] = useState(Date.now());

      useEffect(() => {
        if (!localStorage.getItem(SAVE_KEY)) {
            showToast("–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –ö—É–ø–∏—Ç–µ —Å–µ–º–µ–Ω–∞ –≤ Shop –∏ —Å–∞–∂–∞–π—Ç–µ –∏—Ö –≤ Plant.");
            setGameState(prev => ({...prev, orders: generateOrders(3)}));
        }
        localStorage.setItem(SAVE_KEY, JSON.stringify(gameState));
      }, [gameState]);

      const showToast = useCallback((message, isError = false) => {
        setToast(message);
        if (isError) haptic('error');
        setTimeout(() => setToast(null), 3000);
      }, []);

      const gameTick = useCallback(() => {
        const currentTime = Date.now();
        setNow(currentTime);

        setGameState(prev => {
          const newState = JSON.parse(JSON.stringify(prev));
          const dtSec = (currentTime - newState.lastActiveAt) / 1000;
          
          const energyDt = currentTime - newState.eco.energy.lastRefill;
          const energyGained = Math.floor(energyDt / 60000 * newState.eco.energy.regenPerMinute);
          if (energyGained > 0) {
              newState.eco.energy.current = Math.min(newState.eco.energy.max, newState.eco.energy.current + energyGained);
              newState.eco.energy.lastRefill += energyGained * (60000 / newState.eco.energy.regenPerMinute);
          }

          if (currentTime - newState.world.lastWeatherUpdate >= Ticks.WEATHER) {
              newState.world.weather = ['Sunny', 'Rainy', 'Cloudy'][Math.floor(Math.random() * 3)];
              newState.world.lastWeatherUpdate = currentTime;
          }
          newState.plots.forEach((plot) => {
              if (plot.crop) {
                  const cropData = CROP_DATA[plot.crop.type];
                  if (newState.world.weather === 'Rainy') plot.crop.water = clamp(plot.crop.water + 0.5 * dtSec, 0, 100);
                  plot.crop.water = clamp(plot.crop.water - cropData.decayWater * dtSec, 0, 100);
                  plot.crop.fertilizer = clamp(plot.crop.fertilizer - cropData.decayFert * dtSec, 0, 100);
                  const inGreenZone = plot.crop.water >= 60 && plot.crop.fertilizer >= 40;
                  if (inGreenZone) plot.crop.quality = clamp(plot.crop.quality + cropData.qualityPerTick * dtSec, 1, 2);
                  if (plot.crop.progress < 1) {
                      const inRedZone = plot.crop.water < 20 || plot.crop.fertilizer < 20;
                      const speed = (newState.world.weather === 'Sunny' ? 1 : 0.9) * (inRedZone ? 0.5 : 1);
                      plot.crop.progress = clamp(plot.crop.progress + dtSec / cropData.growTime * speed, 0, 1);
                  }
                  plot.crop.stage = plot.crop.progress >= 1 ? 'Mature' : (plot.crop.progress >= 0.5 ? 'Sprout' : 'Seed');
              }
          });
          
          if (currentTime - (newState.eco.lastMarketUpdate || 0) >= Ticks.MARKET) {
              for (const key in newState.eco.marketTrend) {
                  const trend = newState.eco.marketTrend[key];
                  newState.eco.marketTrend[key] = clamp(trend + (Math.random() - 0.5) * 0.1, 0.85, 1.25);
              }
              newState.eco.lastMarketUpdate = currentTime;
          }
          if (currentTime - (newState.world.lastOrdersUpdate || 0) >= Ticks.ORDERS) {
              newState.orders = generateOrders(3); newState.world.lastOrdersUpdate = currentTime;
          }

          newState.lastActiveAt = currentTime;
          return newState;
        });
      }, []);

      useEffect(() => { const timer = setInterval(gameTick, Ticks.GAME); return () => clearInterval(timer); }, [gameTick]);

      const spendEnergy = (amount) => {
          if (gameState.eco.energy.current < amount) { showToast("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —ç–Ω–µ—Ä–≥–∏–∏! ‚ö°", true); return false; }
          setGameState(prev => ({ ...prev, eco: { ...prev.eco, energy: { ...prev.eco.energy, current: prev.eco.energy.current - amount } } }));
          return true;
      }
      
      const handlePlotClick = (plot) => {
        if (plot.crop?.stage === 'Mature') handleHarvest(plot.id);
        else if (!plot.crop) handlePlant(plot.id);
      }

      const handlePlant = (plotId) => {
          const seedType = selectedSeed;
          if ((gameState.inv.seeds[seedType] || 0) < 1) { showToast(`–ö—É–ø–∏—Ç–µ —Å–µ–º–µ–Ω–∞ ${CROP_DATA[seedType].name} –≤ Shop`, true); return; }
          if (!spendEnergy(1)) return;
          haptic('success');
          setGameState(prev => {
              const newPlots = prev.plots.map(p => (p.id === plotId && !p.crop) ? { ...p, crop: { type: seedType, plantedAt: Date.now(), stage: 'Seed', progress: 0, water: 45 + Math.floor(Math.random()*15), fertilizer: 40 + Math.floor(Math.random()*15), quality: 1.0 } } : p);
              if (newPlots.some(p => p.id === plotId && p.crop?.type === seedType)) {
                const newSeeds = { ...prev.inv.seeds, [seedType]: prev.inv.seeds[seedType] - 1 };
                return { ...prev, plots: newPlots, inv: { ...prev.inv, seeds: newSeeds } };
              } else { showToast("–ì—Ä—è–¥–∫–∞ –∑–∞–Ω—è—Ç–∞!", true); return prev; }
          });
      }

      const handleHarvest = (plotId) => {
          const plot = gameState.plots.find(p => p.id === plotId);
          if (!plot?.crop || plot.crop.stage !== 'Mature' || !spendEnergy(1)) return;
          
          const yieldCount = calculateYield(plot.crop);
          haptic('success');
          setGameState(prev => ({...prev,
            plots: prev.plots.map(p => p.id === plotId ? { ...p, crop: undefined } : p),
            inv: {...prev.inv, raw: {...prev.inv.raw, [plot.crop.type]: (prev.inv.raw[plot.crop.type] || 0) + yieldCount }},
          }));
          showToast(`–°–æ–±—Ä–∞–Ω–æ ${CROP_DATA[plot.crop.type].name} x${yieldCount}`);
      }

      const handleCareFor = (plotId, action) => {
          const plot = gameState.plots.find(p => p.id === plotId);
          if (!plot?.crop) { showToast("–ó–¥–µ—Å—å –Ω–µ—á–µ–≥–æ –ø–æ–ª–∏–≤–∞—Ç—å/—É–¥–æ–±—Ä—è—Ç—å", true); return; }
          
          if (action === 'water' && spendEnergy(1)) {
            haptic('light');
            setGameState(prev => ({...prev, plots: prev.plots.map(p => p.id === plotId ? {...p, crop: {...p.crop, water: clamp(p.crop.water + 25, 0, 100), lastWateredAt: Date.now()}} : p)}));
          } else if (action === 'fertilize') {
            if (gameState.inv.items.Fertilizer < 1) { showToast("–ù–µ—Ç —É–¥–æ–±—Ä–µ–Ω–∏–π", true); return; }
            if (spendEnergy(2)) {
                haptic('light');
                setGameState(prev => ({...prev,
                    plots: prev.plots.map(p => p.id === plotId ? {...p, crop: {...p.crop, fertilizer: clamp(p.crop.fertilizer + 25, 0, 100), lastFertilizedAt: Date.now()}} : p),
                    inv: {...prev.inv, items: {...prev.inv.items, Fertilizer: prev.inv.items.Fertilizer - 1}}
                }));
            }
          }
      }

      const handleBuy = (type, key) => {
        const level = gameState.upgrades[key] || 0;
        const cost = type === 'seed' ? CROP_DATA[key].seedPrice : type === 'item' ? (key === 'Fertilizer' ? 5 : 8) : UPGRADE_DATA[key].baseCost + UPGRADE_DATA[key].costScale * level;
        if (gameState.eco.coins < cost) { showToast("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–æ–Ω–µ—Ç!", true); return; }
        haptic('success');
        setGameState(prev => {
            const newState = {...prev, eco: {...prev.eco, coins: prev.eco.coins - cost}};
            if (type === 'seed') newState.inv.seeds[key]++;
            if (type === 'item') newState.inv.items[key]++;
            if (type === 'upgrade') {
                newState.upgrades[key]++;
                if (key === 'EnergyCap') newState.eco.energy.max += 5;
                if (key === 'Storage') newState.buildings.storage.capacity += 20;
                if (key === 'EnergyRegen') newState.eco.energy.regenPerMinute += 0.5;
            }
            return newState;
        });
        showToast("–ü–æ–∫—É–ø–∫–∞ —Å–æ–≤–µ—Ä—à–µ–Ω–∞!");
      }

      const handleSell = (item, amount) => {
          const qty = amount === 'one' ? 1 : (gameState.inv.raw[item] || 0);
          if (qty === 0) return;
          const price = Math.floor(CROP_DATA[item].basePrice * gameState.eco.marketTrend[item]);
          haptic('success');
          setGameState(prev => ({...prev, 
              eco: {...prev.eco, coins: prev.eco.coins + (price * qty)},
              inv: {...prev.inv, raw: {...prev.inv.raw, [item]: prev.inv.raw[item] - qty}}
          }));
          showToast(`–ü—Ä–æ–¥–∞–Ω–æ –Ω–∞ ${price * qty}üí∞`);
      }
      
      const handleFulfillOrder = (order) => {
        if (order.requires.every(req => (gameState.inv.raw[req.item] || 0) >= req.qty)) {
            haptic('success');
            setGameState(prev => {
                const newRaw = {...prev.inv.raw};
                order.requires.forEach(req => newRaw[req.item] -= req.qty);
                return {...prev, inv: {...prev.inv, raw: newRaw}, eco: { ...prev.eco, coins: prev.eco.coins + order.rewardCoins, gems: prev.eco.gems + (order.rewardGems || 0) }, orders: prev.orders.filter(o => o.id !== order.id) }
            });
            showToast(`–ó–∞–∫–∞–∑ –≤—ã–ø–æ–ª–Ω–µ–Ω! +${order.rewardCoins}üí∞`);
        } else { showToast("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Ä–µ—Å—É—Ä—Å–æ–≤!", true); }
      }
      
      const { eco, inv, plots, world } = gameState;
      const getWeatherIcon = (weather) => ({'Sunny': '‚òÄÔ∏è', 'Rainy': 'üåßÔ∏è', 'Cloudy': '‚òÅÔ∏è'}[weather]);
      
      return (
        <div className="app-container text-gray-800 font-sans">
            {toast && <div className="toast bg-blue-500 text-white px-6 py-2 rounded-full shadow-lg animate-bounce">{toast}</div>}
            
            <div className="play-area bg-green-400 flex-[2] relative">
                <div className="absolute top-2 right-2 flex flex-col items-end gap-1 text-sm z-10">
                    <div className="bg-yellow-400 text-yellow-900 font-bold px-3 py-1 rounded-full shadow-md">üí∞ {eco.coins}</div>
                    <div className="bg-purple-400 text-purple-900 font-bold px-3 py-1 rounded-full shadow-md">üíé {eco.gems}</div>
                    <div className="bg-blue-300 text-blue-900 font-bold px-3 py-1 rounded-full shadow-md leading-tight flex flex-col items-end">
                      <span>‚ö° {eco.energy.current}/{eco.energy.max}</span>
                      <span className="energy-timer">
                        {eco.energy.current >= eco.energy.max ? 'Full' : `+1 in ${fmtMMSS(energySecondsToNext(eco.energy, now))}`}
                      </span>
                    </div>
                </div>
                <div className="absolute top-2 left-2 text-3xl">{getWeatherIcon(world.weather)}</div>
                <div className="plots">
                    {plots.map(plot => (
                        <div key={plot.id} onClick={() => handlePlotClick(plot)} className="plot cursor-pointer transition-all duration-200">
                            {plot.crop ? (<>
                                {now - (plot.crop.lastWateredAt || 0) < 2000 && <span className="absolute text-lg animate-ping z-20">üíß</span>}
                                {now - (plot.crop.lastFertilizedAt || 0) < 2000 && <span className="absolute text-lg animate-ping z-20">üåø</span>}
                                
                                <div className="absolute top-1 right-1 flex gap-1 z-10">
                                    <button onClick={(e) => { e.stopPropagation(); handleCareFor(plot.id, 'water'); }} className="bg-black/30 rounded px-1 text-xs" title="–ü–æ–ª–∏—Ç—å 1‚ö°">üíß</button>
                                    <button onClick={(e) => { e.stopPropagation(); handleCareFor(plot.id, 'fertilize'); }} className="bg-black/30 rounded px-1 text-xs" title="–£–¥–æ–±—Ä–∏—Ç—å 2‚ö°">üåø</button>
                                </div>

                                <div className="text-4xl">{CROP_DATA[plot.crop.type].icon}</div>
                                <div className="text-xs text-white bg-black/30 rounded-full px-1.5 -mt-1">{plot.crop.stage}</div>
                                {plot.crop.stage === 'Mature' && <div className="text-xs font-bold text-green-300">x{calculateYield(plot.crop)}</div>}
                                
                                <div className="absolute bottom-1 left-1 right-1 flex flex-col gap-0.5">
                                    <div className="h-1.5 bg-black/20 rounded-full"><div style={{width: `${plot.crop.water}%`}} className="h-full bg-blue-400 rounded-full"></div></div>
                                    <div className="h-1.5 bg-black/20 rounded-full"><div style={{width: `${plot.crop.fertilizer}%`}} className="h-full bg-orange-400 rounded-full"></div></div>
                                </div>
                            </>) : <div className="text-gray-400 text-xs text-center">–ü—É—Å—Ç–æ</div>}
                        </div>
                    ))}
                </div>
            </div>
            <div className="bottom-panel bg-yellow-800/90 w-full p-2 text-white">
                <div className="flex justify-center gap-1 mb-2">
                    {(['Plant', 'Shop', 'Orders', 'Inventory']).map(tab => <button key={tab} onClick={() => setActiveTab(tab)} className={`px-2 py-1 text-xs rounded-t-lg ${activeTab === tab ? 'bg-yellow-600 font-bold' : 'bg-yellow-900'}`}>{tab}</button>)}
                </div>
                <div className="panel-scroll bg-yellow-600 rounded-lg p-2 text-xs">
                    {activeTab === 'Plant' && <div><h3 className="text-center font-bold mb-1">–ü–æ—Å–∞–¥–∫–∞</h3><div className="flex justify-around bg-black/20 p-1 rounded-md mb-2">{Object.entries(CROP_DATA).map(([key, c]) => (<button key={key} onClick={() => setSelectedSeed(key)} className={`p-1 rounded ${selectedSeed === key ? 'bg-green-500' : ''}`}>{c.icon} {inv.seeds[key] || 0}</button>))}</div>{Object.values(inv.seeds).every(v=>v===0) && Object.values(inv.raw).every(v=>v===0) && <p className="text-center bg-red-800 p-1 rounded">–ù–µ—Ç —Å–µ–º—è–Ω! –û—Ç–∫—Ä–æ–π—Ç–µ Shop –∏ –∫—É–ø–∏—Ç–µ Carrot Seeds (5üí∞).</p>}</div>}
                    {activeTab === 'Shop' && <div><h3 className="font-bold mb-1 text-center">–ú–∞–≥–∞–∑–∏–Ω</h3><strong>–°–µ–º–µ–Ω–∞:</strong><div className="flex gap-2 mb-2">{Object.entries(CROP_DATA).map(([key, val]) => <button key={key} disabled={eco.coins < val.seedPrice} onClick={() => handleBuy('seed', key)} className="flex-1 p-1 bg-green-700 rounded disabled:opacity-50">{val.icon} {val.seedPrice}üí∞</button>)}</div><strong>–£—Ö–æ–¥:</strong><div className="flex gap-2 mb-2"><button onClick={() => handleBuy('item', 'Fertilizer')} disabled={eco.coins < 5} className="flex-1 p-1 bg-orange-700 rounded disabled:opacity-50">–£–¥–æ–±—Ä–µ–Ω–∏–µ 5üí∞</button><button onClick={() => handleBuy('item', 'PestControl')} disabled={eco.coins < 8} className="flex-1 p-1 bg-red-700 rounded disabled:opacity-50">–ó–∞—â–∏—Ç–∞ 8üí∞</button></div><strong>–£–ª—É—á—à–µ–Ω–∏—è:</strong>{Object.entries(UPGRADE_DATA).map(([key, val]) => { const lvl = gameState.upgrades[key] || 0; const cost = val.baseCost + val.costScale * lvl; return <button key={key} disabled={eco.coins < cost} onClick={()=>handleBuy('upgrade', key)} className="w-full p-1 bg-purple-700 rounded mb-1 disabled:opacity-50 text-left">{val.name} (Lvl {lvl})<span className="float-right">{cost}üí∞</span></button> })}</div>}
                    {activeTab === 'Orders' && <div><h3 className="font-bold mb-1 text-center">–ó–∞–∫–∞–∑—ã</h3>{gameState.orders.length === 0 ? <p className="text-center opacity-70">–ù–æ–≤—ã–µ –∑–∞–∫–∞–∑—ã —Å–∫–æ—Ä–æ –ø–æ—è–≤—è—Ç—Å—è...</p> : gameState.orders.map(order => (<div key={order.id} className="bg-black/20 p-1.5 rounded mb-1"><div>–¢—Ä–µ–±—É–µ—Ç—Å—è: {order.requires.map(r => `${r.item} x${r.qty}`).join(', ')}</div><div>–ù–∞–≥—Ä–∞–¥–∞: {order.rewardCoins}üí∞ {order.rewardGems && `${order.rewardGems}üíé`}</div><div className="flex justify-between items-center"><span className="opacity-70">–ò—Å—Ç–µ–∫–∞–µ—Ç: {formatTime((order.expiresAt - now)/1000)}</span><button onClick={() => handleFulfillOrder(order)} disabled={!order.requires.every(req => (inv.raw[req.item] || 0) >= req.qty)} className="px-2 py-0.5 bg-green-600 rounded disabled:opacity-50">–°–¥–∞—Ç—å</button></div></div>))}</div>}
                    {activeTab === 'Inventory' && <div><h3 className="font-bold mb-1 text-center">–ò–Ω–≤–µ–Ω—Ç–∞—Ä—å –∏ –ü—Ä–æ–¥–∞–∂–∞</h3>{Object.keys(inv.raw).filter(k => (inv.raw[k] || 0) > 0).length === 0 ? <p className="opacity-70 text-center">–°–æ–±–µ—Ä–∏—Ç–µ —É—Ä–æ–∂–∞–π, —á—Ç–æ–±—ã –ø—Ä–æ–¥–∞—Ç—å –µ–≥–æ –∑–¥–µ—Å—å.</p> : Object.entries(inv.raw).map(([key, val]) => val > 0 && <div key={key} className="flex items-center justify-between bg-black/20 p-1 rounded mb-1"><span>{CROP_DATA[key].icon} {key}: {val} (x{eco.marketTrend[key].toFixed(2)})</span><div className="flex gap-1"><button onClick={() => handleSell(key, 'one')} className="px-2 bg-red-600 rounded">1</button><button onClick={() => handleSell(key, 'all')} className="px-2 bg-red-800 rounded">–í—Å–µ</button></div></div>)}</div>}
                </div>
                <div className="text-center text-xs opacity-60 mt-1">‚ö° +{eco.energy.regenPerMinute.toFixed(1)}/–º–∏–Ω ¬∑ –ü–æ—Å–∞–¥–∫–∞ 1‚ö° ¬∑ –ü–æ–ª–∏–≤ 1‚ö° ¬∑ –£–¥–æ–±—Ä–µ–Ω–∏–µ 2‚ö° ¬∑ –°–±–æ—Ä 1‚ö°</div>
            </div>
        </div>
      )
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>

