<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Grow Garden TMA</title>
  
  <!-- Telegram Web App SDK -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  
  <!-- React CDN -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  
  <!-- Babel for JSX in browser -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Tailwind CSS for styling -->
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    :root { 
      color-scheme: light dark; 
      --panel-h: 260px;
      --hud-h: 68px;
    }
    html, body, #root { height: 100%; margin: 0; padding: 0; }
    body {
      background: var(--tg-theme-bg-color, #f1f5f1);
      color: var(--tg-theme-text-color, #000);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      overflow: hidden; /* Prevent body scroll */
    }

    /* HUD */
    .hud {
      position: fixed; top: 0; left: 50%; transform: translateX(-50%);
      width: min(100%, 540px);
      height: var(--hud-h);
      z-index: 40;
      padding-top: max(8px, env(safe-area-inset-top));
      padding-bottom: 8px;
      padding-left: max(16px, env(safe-area-inset-left) + 8px);
      padding-right: max(16px, env(safe-area-inset-right) + 8px);
      display: flex; justify-content: space-between; align-items: flex-start;
      pointer-events: none;
    }
    .hud > * { pointer-events: auto; }
    .hud-resources { 
      display: flex; 
      gap: 8px;
      margin-left: 8px;
      padding-left: 12px;
      align-items: center;
      flex-wrap: wrap;
    }
    .hud-events {
      position: absolute;
      top: calc(max(8px, env(safe-area-inset-top)) + 36px);
      left: 12px;
      z-index: 38;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .event-card {
      background: rgba(0,0,0,0.5);
      color: white;
      padding: 4px 8px;
      border-radius: 8px;
      backdrop-filter: blur(4px);
      font-size: 12px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    /* Контейнер приложения */
    .app-container{
      min-height: 100svh;
      height: 100%;
      max-width:540px;
      width:min(100vw,540px);
      margin:0 auto;
      display:flex;
      flex-direction:column;
      padding-left:max(12px, env(safe-area-inset-left));
      padding-right:max(12px, env(safe-area-inset-right));
      box-sizing:border-box;
    }

    /* Верхняя игровая зона */
    .play-area{
      position:relative;
      width:100%;
      margin:0 auto;
      overflow:auto;
      background-image:url('https://raw.githubusercontent.com/Poklontsevv/growgarden/main/background.png');
      background-size:cover;
      background-position:center;
      flex:1 1 auto;
      padding: 12px;
      padding-top: calc(var(--hud-h) + max(8px, env(safe-area-inset-top)) + 24px);
      padding-bottom: calc(var(--panel-h) + max(10px, env(safe-area-inset-bottom)));
    }

    .plots-wrap{ position: relative; width: 100%; }
    .plots{
      --plot-max: 132px;
      display: grid;
      gap: clamp(6px, 1.2vw, 12px);
      grid-template-columns: repeat(auto-fill, minmax(96px, var(--plot-max)));
      justify-content: center;
      width: 100%;
      margin: 0 auto;
    }
    @media (min-width:480px){ .plots{ --plot-max: 140px; } }
    @media (min-width:768px){ .plots{ --plot-max: 148px; } }
    
    .plot-cell{ position:relative; padding-top: 44px; }
    .plot-toolbar{
      position:absolute;
      left:0; right:0; top:2px;
      height:40px;
      background:#a8743a;
      color:#fff;
      border-radius:10px;
      display:flex;
      align-items:center;
      justify-content: center;
      padding:0 6px;
      gap: 8px;
      box-shadow:0 2px 6px rgba(0,0,0,.25);
      z-index:10;
    }
    .toolbar-btn{
      width:36px; height:36px;
      border:none; border-radius:10px;
      display:flex; align-items:center; justify-content:center;
      background:rgba(0,0,0,.2); color:#fff; font-size:18px;
    }
    .toolbar-btn:active{ transform:scale(.96); }
    .plot-timer{
      position: absolute;
      top: 4px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.35);
      color: white;
      font-size: 12px;
      font-weight: 600;
      padding: 2px 6px;
      border-radius: 9999px;
      z-index: 15;
    }
    
    .plot{
      position: relative;
      aspect-ratio: 1/1;
      background-image: url('https://raw.githubusercontent.com/Poklontsevv/growgarden/main/garden_bed%202.png');
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      display: flex; align-items: center; justify-content: center;
      font-size: clamp(2.2em, 5vw, 2.6em);
      overflow: hidden;
    }
    
    .plot-figure{
      position: absolute;
      left: 50%;
      bottom: 14%;
      transform: translateX(-50%);
      width: 100%;
      height: 86%;
      display: flex;
      justify-content: center;
      align-items: flex-end;
      pointer-events: none;
    }

    .crop-img{
      display: block;
      height: auto;
      object-fit: contain;
      max-height: 72%;
    }

    .crop-img--seed   { max-width: 40%; }
    .crop-img--sprout { max-width: 46%; }
    .crop-img--plant  { max-width: 48%; }

    .plot-actions{ display:none!important; }
    .h-1\.5{height:.4em}

    .bottom-panel{
      position:fixed;
      left:50%;
      transform:translateX(-50%);
      bottom:0;
      z-index:30;
      max-width:540px;
      width:100%;
      height:var(--panel-h);
      border-radius:12px 12px 0 0;
      background: rgba(120, 72, 0, .92);
      padding:8px 8px max(10px, env(safe-area-inset-bottom)) 8px;
      display:flex;
      flex-direction:column;
    }
    .panel-scroll{
      flex:1 1 auto;
      overflow:auto;
      scrollbar-width:thin;
    }
    .panel-scroll::-webkit-scrollbar{ width:4px; }
    .panel-scroll::-webkit-scrollbar-thumb{ background: rgba(0,0,0,.2); border-radius: 2px; }

    .toast{ position: fixed; top: max(8px, calc(env(safe-area-inset-top) + 8px)); left: 50%; transform: translateX(-50%); z-index: 50; }
    .energy-timer{ font-size: 10px; line-height: 1; opacity: .85; }
    
    @keyframes grow-pop{0%{transform:scale(.7);opacity:0}100%{transform:scale(1);opacity:1}}
    .stage-pop{animation:grow-pop .25s ease-out}
    @keyframes pulse-hot { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); } }
    .hot-pulse { animation: pulse-hot 1.5s ease-in-out infinite; }
    @keyframes heat-pulse { 0%,100%{transform:scale(1)} 50%{transform:scale(1.06)} }
    .heat-pulse{ animation: heat-pulse 1.2s ease-in-out infinite; }
    
    @keyframes pulse-halo { 0%, 100% { opacity: 0.2; transform: scale(1); } 50% { opacity: 0.3; transform: scale(1.05); } }
    @keyframes pulse-bar { 0%, 100% { filter: brightness(1); } 50% { filter: brightness(1.5); } }
    .plot.plot--heated::after, .plot.plot--hot::after {
      content: '';
      position: absolute;
      inset: -4px;
      border-radius: 14px;
      background: radial-gradient(circle, rgba(255, 100, 0, 0.5) 0%, rgba(255, 69, 0, 0) 70%);
      animation: pulse-halo 1.3s ease-in-out infinite;
      z-index: -1;
    }
    .plot.plot--hot::after {
      background: radial-gradient(circle, rgba(255, 60, 0, 0.6) 0%, rgba(255, 20, 0, 0) 70%);
      animation-duration: 1.1s;
    }
    .plot.plot--heated .status-bar-div, .plot.plot--hot .status-bar-div {
      animation: pulse-bar 1.3s ease-in-out infinite;
    }

    /* насекомые должны быть под HUD (40) и под нижней панелью (30) */
    .bug-layer{
      pointer-events:none;
      position:absolute;
      inset:0;
      z-index:20;
    }
    /* контейнер одного насекомого */
    .bug{
      position:absolute;
      filter: drop-shadow(0 1px 2px rgba(0,0,0,.25));
      pointer-events:auto;
      cursor:pointer;
      /* расширяем хитбокс без визуального увеличения */
      padding: 22px;            /* зона клика вокруг спрайта */
      margin-left: -22px;
      margin-top: -22px;
      touch-action: none;                   /* не перехватывать скролл/зум */
      -webkit-tap-highlight-color: transparent;
    }
    
    /* маленькие UI-иконки в кнопках/лейблах */
    .ui-icon {
      width: 18px; height: 18px; 
      display:inline-block; vertical-align:middle; 
      object-fit:contain;
    }

    /* сам спрайт занимает исходные width/height контейнера */
    .bug-sprite, .beetle-sprite {
      width: 100%;
      height: 100%;
      display: block;
      object-fit: contain;
      pointer-events: none;      /* чтобы клик ловил .bug */
    }

    .floater {
      position: fixed;
      z-index: 60;
      font-weight: 800;
      font-size: 14px;
      pointer-events: none;
      transform: translate(-50%, -50%);
      animation: floater-up 900ms ease-out forwards;
      text-shadow: 0 1px 2px rgba(0,0,0,.35);
      color: white;
    }
    @keyframes floater-up {
      0%   { opacity: 0; transform: translate(-50%, -10%) scale(.9); }
      15%  { opacity: 1; transform: translate(-50%, -24%) scale(1); }
      100% { opacity: 0; transform: translate(-50%, -70%) scale(1.05); }
    }
    .badge {
      margin-left: 6px;
      padding: 1px 6px;
      border-radius: 999px;
      background: rgba(0,0,0,.35);
      font-size: 11px;
      display: inline-block;
    }
    .coins-bounce { animation: coins-bounce 350ms ease-out; }
    @keyframes coins-bounce {
      0% { transform: scale(1); }
      50% { transform: scale(1.12); }
      100% { transform: scale(1); }
    }
    .plot.plot--attacked::after {
      content: '';
      position: absolute; inset: -4px; border-radius: 14px;
      background: radial-gradient(circle, rgba(255,0,0,0.35) 0%, rgba(255,0,0,0) 70%);
      animation: pulse-halo 1.05s ease-in-out infinite;
      z-index: -1;
    }
    .plot-attack-icons {
      position: absolute; top: 2px; right: 4px;
      font-size: 12px; font-weight: 700; color: #fff;
      background: rgba(0,0,0,.4); padding: 2px 6px; border-radius: 999px;
      z-index: 5;
    }
    .seed-icon { width: 24px; height: 24px; object-fit: contain; display:inline-block; }
    .shop-icon { width: 22px; height: 22px; object-fit: contain; display:inline-block; margin-right: 4px; }
    
    .damage-banner .title { font-weight: 700; font-size: 12px; }
    .damage-banner .subtitle { font-size: 11px; opacity: .9; }
    .damage-bar{
      position: relative; height: 6px; background: rgba(255,255,255,.22);
      border-radius: 9999px; overflow: hidden; margin-top: 4px;
    }
    .damage-bar > span{
      position:absolute; inset:0 auto 0 0; width:100%;
      background: linear-gradient(90deg, #ef4444, #f97316);
      opacity:.7; animation: damage-fill 420ms ease-out;
    }
    @keyframes damage-fill{ from{ width: 10%; } to{ width: 100%; } }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useCallback, useMemo, useRef } = React;
    
    const tg = window.Telegram?.WebApp;
    if (tg) { tg.ready(); tg.expand(); tg.setHeaderColor('bg_color'); tg.setBackgroundColor('bg_color'); }
    function applyTheme() {
      const p = tg?.themeParams || {};
      document.documentElement.style.setProperty('--tg-theme-bg-color', p.bg_color || '#f1f5f1');
      document.documentElement.style.setProperty('--tg-theme-text-color', p.text_color || '#000000');
    }
    applyTheme();
    tg?.onEvent('themeChanged', applyTheme);
    function haptic(kind) { try { if (!tg?.HapticFeedback) return; if (kind === 'success') tg.HapticFeedback.notificationOccurred('success'); else if (kind === 'error') tg.HapticFeedback.notificationOccurred('error'); else tg.HapticFeedback.impactOccurred('light'); } catch {} }
    const tgUserId = (tg && tg.initDataUnsafe?.user?.id) ? String(tg.initDataUnsafe.user.id) : 'dev';
    const SAVE_KEY = `growGardenState:${tgUserId}`;

    // --- GAME CODE STARTS HERE ---
    const Ticks = { GAME: 1000, WEATHER: 15 * 60 * 1000, MARKET: 5 * 60 * 1000, ORDERS: 10 * 60 * 1000, SHOP: 5 * 60 * 1000 };
    const OFFLINE_CAP_HOURS = 3;
    
    const INSECT_TUNING = {
      sizeMinPct: 20,
      sizeMaxPct: 36,
      speedScale: 0.40,
      clickPadding: 22
    };

    const INSECT_CAP = { bug: 8, beetle: 6 };

    const DAMAGE_TUNING = {
      bug: { waterPerSec: 3, fertPerSec: 2, shieldMultiplier: 0.5 },
      beetle: { freezeExtendSec: 1.2, leaveRollback: 0.04, minDwellForRollbackSec: 2, rollbackCooldownSec: 5 }
    };

    const INSECT_LOOT = {
      coinChance: 0.25,
      energyChance: 0.08,
      gemChance: 0.015,
      coinPerKillMin: 1,
      coinPerKillMax: 2,
      budget: {
        coinsMin: 4, coinsMax: 8,
        energyMin: 2, energyMax: 4,
        gemsMin: 0, gemsMax: 1
      }
    };

    const COMPENSATION = {
      bugHealPct: 5,
      beetleBuff: { mulPerStack: 0.10, durationMs: 10000, maxStacks: 2 },
    };

    const rand = (min, max) => min + Math.random() * (max - min);
    const randInt = (min, max) => Math.floor(rand(min, max + 1));
    const clamp = (num, min, max) => Math.min(Math.max(num, min), max);
    const fmtMMSS = (totalSec) => { if (totalSec < 0) totalSec = 0; const m = Math.floor(totalSec / 60); const s = totalSec % 60; return `${m}:${s < 10 ? '0' : ''}${s}`; };
    function formatTime(seconds){
      if (seconds < 0) seconds = 0;
      const m = Math.floor(seconds / 60);
      const s = Math.floor(seconds % 60);
      return `${m}:${s < 10 ? '0' : ''}${s}`;
    }
    function energySecondsToNext(energy, now) { if (energy.current >= energy.max) return 0; const intervalMs = 60000 / Math.max(0.0001, energy.regenPerMinute); const msPassedSinceLastRegen = now - energy.lastRefill; const msLeft = intervalMs - (msPassedSinceLastRegen % intervalMs); return Math.ceil(msLeft / 1000); }
    
    const plantedCount = (state) =>
      state.plots.reduce((acc, p) => acc + (p.crop ? 1 : 0), 0);

    const visibleYPct = (paEl) => {
      if (!paEl) return 50;
      const { scrollTop, clientHeight, scrollHeight } = paEl;
      const yPx = scrollTop + Math.random() * clientHeight;
      return clamp((yPx / scrollHeight) * 100, 2, 98);
    };

    const ICONS = {
      water:      "https://raw.githubusercontent.com/Poklontsevv/growgarden/main/watering.png",
      fertilizer: "https://raw.githubusercontent.com/Poklontsevv/growgarden/main/fertilizer%202.png",
      protect:    "https://raw.githubusercontent.com/Poklontsevv/growgarden/main/protect%202.png",
    };
    
    const CROP_ICON_URL = {
      Blueberry: "https://raw.githubusercontent.com/Poklontsevv/growgarden/main/blueberry.png",
      Carrot:    "https://raw.githubusercontent.com/Poklontsevv/growgarden/main/carrot.png",
      Coffee:    "https://raw.githubusercontent.com/Poklontsevv/growgarden/main/coffee.png",
      Corn:      "https://raw.githubusercontent.com/Poklontsevv/growgarden/main/corn.png",
      Cucumber:  "https://raw.githubusercontent.com/Poklontsevv/growgarden/main/cucumber.png",
      Garlic:    "https://raw.githubusercontent.com/Poklontsevv/growgarden/main/garlic.png",
      Ginseng:   "https://raw.githubusercontent.com/Poklontsevv/growgarden/main/ginseng.png",
      Herb:      "https://raw.githubusercontent.com/Poklontsevv/growgarden/main/herbs.png",
      Onion:     "https://raw.githubusercontent.com/Poklontsevv/growgarden/main/onion.png",
      Potato:    "https://raw.githubusercontent.com/Poklontsevv/growgarden/main/potato.png",
      Pumpkin:   "https://raw.githubusercontent.com/Poklontsevv/growgarden/main/pumpkin.png",
      Strawberry:"https://raw.githubusercontent.com/Poklontsevv/growgarden/main/strawberry.png",
      Sunflower: "https://raw.githubusercontent.com/Poklontsevv/growgarden/main/sunflower.png",
      Tomato:    "https://raw.githubusercontent.com/Poklontsevv/growgarden/main/tomato.png",
      Wheat:     "https://raw.githubusercontent.com/Poklontsevv/growgarden/main/wheat.png",
    };

    const ENEMY_IMG_BEETLE = "https://raw.githubusercontent.com/Poklontsevv/growgarden/main/bug.png";

    const stageIcon = (type, stage) => {
      const cls = (s) => `crop-img ${s}`;
      if (stage === 'Seed') return <img src="https://raw.githubusercontent.com/Poklontsevv/growgarden/main/seed.png" alt="Seed" className={cls('crop-img--seed')} />;
      const sprite = (sproutUrl, plantUrl, altBase) => ( stage === 'Sprout' ? <img src={sproutUrl} alt={`${altBase} sprout`} className={cls('crop-img--sprout')} /> : <img src={plantUrl}  alt={`${altBase} plant`}  className={cls('crop-img--plant')}  /> );
      const SPRITE_MAP = {
        Coffee: ['coffee_sprout.png', 'coffee_plant.png'], Corn: ['corn_sprout.png', 'corn_plant.png'],
        Cucumber: ['cucumber_sprout.png', 'cucumber_plant.png'], Blueberry: ['blueberry_sprout.png', 'blueberry_plant.png'],
        Carrot: ['carrot_sprout.png', 'carrot_plant.png'], Garlic: ['garlic_sprout.png', 'garlic_plant.png'],
        Ginseng: ['ginseng_sprout.png', 'ginseng_plant.png'], Herb: ['herbs_sprout.png', 'herbs_plant.png'],
        Onion: ['onion_sprout.png', 'onion_plant.png'], Potato: ['potato_sprout.png', 'potato_plant.png'],
        Strawberry: ['strawberry_sprout.png', 'strawberry_plant.png'], Sunflower: ['sunflower_sprout.png', 'sunflower_plant.png'],
        Tomato: ['tomato_sprout.png', 'tomao_plant.png'], Wheat: ['wheat_sprout.png', 'wheat_plant.png'],
        Pumpkin: ['pumpkin_sprout.png', 'pumpkin_plant.png']
      };
      if (SPRITE_MAP[type]) { const [sprout, plant] = SPRITE_MAP[type]; return sprite(`https://raw.githubusercontent.com/Poklontsevv/growgarden/main/${sprout}`, `https://raw.githubusercontent.com/Poklontsevv/growgarden/main/${plant}`, type); }
      return stage === 'Sprout' ? '🌿' : CROP_DATA[type].icon;
    };
    
    const CROP_DATA = {
        Carrot:    { name: 'Морковь', icon: '🥕', growTime: 30, basePrice: 4, seedPrice: 5, baseYield: 2, rarity: 'common' },
        Herb:      { name: 'Травы', icon: '🌿', growTime: 45, basePrice: 5, seedPrice: 6, baseYield: 4, rarity: 'common' },
        Wheat:     { name: 'Пшеница', icon: '🌾', growTime: 50, basePrice: 6, seedPrice: 7, baseYield: 5, rarity: 'common' },
        Potato:    { name: 'Картофель', icon: '🥔', growTime: 70, basePrice: 8, seedPrice: 10, baseYield: 3, rarity: 'common' },
        Tomato:    { name: 'Помидор', icon: '🍅', growTime: 60, basePrice: 7, seedPrice: 8, baseYield: 3, rarity: 'uncommon' },
        Corn:      { name: 'Кукуруза', icon: '🌽', growTime: 80, basePrice: 10, seedPrice: 12, baseYield: 2, rarity: 'uncommon' },
        Cucumber:  { name: 'Огурец', icon: '🥒', growTime: 75, basePrice: 9, seedPrice: 11, baseYield: 4, rarity: 'uncommon' },
        Onion:     { name: 'Лук', icon: '🧅', growTime: 65, basePrice: 8, seedPrice: 9, baseYield: 6, rarity: 'uncommon' },
        Sunflower: { name: 'Подсолнух', icon: '🌻', growTime: 90, basePrice: 12, seedPrice: 15, baseYield: 1, rarity: 'rare' },
        Strawberry:{ name: 'Клубника', icon: '🍓', growTime: 120, basePrice: 18, seedPrice: 22, baseYield: 5, rarity: 'rare' },
        Pumpkin:   { name: 'Тыква', icon: '🎃', growTime: 150, basePrice: 25, seedPrice: 30, baseYield: 1, rarity: 'rare' },
        Garlic:    { name: 'Чеснок', icon: '🧄', growTime: 100, basePrice: 15, seedPrice: 18, baseYield: 8, rarity: 'rare' },
        Blueberry: { name: 'Голубика', icon: '🫐', growTime: 240, basePrice: 40, seedPrice: 50, baseYield: 6, rarity: 'epic' },
        Coffee:    { name: 'Кофе', icon: '☕', growTime: 300, basePrice: 60, seedPrice: 75, baseYield: 3, rarity: 'epic' },
        Ginseng:   { name: 'Женьшень', icon: '🌱', growTime: 600, basePrice: 150, seedPrice: 180, baseYield: 1, rarity: 'epic' },
    };
    Object.values(CROP_DATA).forEach(d => { d.stockPerRefresh = {common:10, uncommon:6, rare:4, epic:2}[d.rarity] || 5; });
    
    const UPGRADE_DATA = {
        EnergyCap: { name: 'Макс. энергия', baseCost: 20, costScale: 10, effect: (lvl) => `+5 Макс. ⚡` },
        Storage: { name: 'Склад', baseCost: 25, costScale: 15, effect: (lvl) => `+20 вмест.` },
        EnergyRegen: { name: 'Реген. энергии', baseCost: 30, costScale: 15, effect: (lvl) => `+0.5 ⚡/мин` },
        PlotSlots: { name: 'Доп. грядки', baseCost: 50, costScale: 30, effect: (lvl) => `+1 грядка (макс. 16)` },
    }

    const calculateYield = (crop) => { const d = CROP_DATA[crop.type]; const qMul = 0.8 + 0.4 * (crop.quality - 1); const minY = Math.max(1, Math.round(d.baseYield)); const maxY = Math.max(minY, Math.round(d.baseYield * (1 + qMul))); return randInt(minY, maxY); };
    function rollShopStock() { const stock = {}; const now = Date.now(); const weights = { common: 1.0, uncommon: 0.6, rare: 0.3, epic: 0.15 }; Object.entries(CROP_DATA).forEach(([key, d]) => { const appear = Math.random() < (weights[d.rarity] ?? 1); stock[key] = { available: appear, qty: appear ? (d.stockPerRefresh ?? 5) : 0 }; }); return { stock, nextRefresh: now + Ticks.SHOP }; }
    
    function growthSpeedMul(crop, world, now){
      let m = (world.weather==='Sunny'?1:0.9);
      const red = (crop.water<20 || crop.fertilizer<20) ? 0.5 : 1;
      m *= red;

      if (crop.frozenUntil && now < crop.frozenUntil) m *= 0;

      if (crop.growthBuffUntil && now < crop.growthBuffUntil) {
        const stacks = clamp(crop.growthBuffStacks || 0, 0, COMPENSATION.beetleBuff.maxStacks);
        m *= (1 + COMPENSATION.beetleBuff.mulPerStack * stacks);
      } else {
        if (crop.growthBuffStacks) crop.growthBuffStacks = 0;
      }

      if (now < crop.waterBoostUntil) m *= 1.25;
      if (now < crop.fertBoostUntil)  m *= 1.15;
      return m;
    }

    function secondsToNextStage(crop, world){
      const d = CROP_DATA[crop.type];
      if (!d || crop.progress >= 1) return 0;
      let speedMod = growthSpeedMul(crop, world, Date.now());
      const basePerSec = (1 / d.growTime) * speedMod;
      const target = crop.progress < 0.5 ? 0.5 : 1.0;
      const remain = Math.max(0, target - crop.progress);
      const perSec = Math.max(1e-6, basePerSec);
      return Math.ceil(remain / perSec);
    }

    const createInitialState = () => ({
      maxPlots: 6,
      plots: Array.from({ length: 6 }, (_, i) => ({ id: `plot-${i}` })),
      inv: { seeds: Object.fromEntries(Object.keys(CROP_DATA).map(k=>[k,0])), raw:{}, items:{Fertilizer:0, PestControl:0} },
      orders: [],
      eco: { coins: 50, gems: 0, energy: { current: 20, max: 20, lastRefill: Date.now(), regenPerMinute: 1 }, marketTrend: Object.fromEntries(Object.keys(CROP_DATA).map(k=>[k,1])), hotPrice: null, },
      world: { 
        weather: 'Sunny', lastWeatherUpdate: Date.now(), lastOrdersUpdate: Date.now(), 
        heatwaveUntil: 0, bugs: [], beetles: [], nextOrderAt: Date.now() + rand(60, 120)*1000, 
        bugAttack: { phase:'idle', announceUntil:0, endsAt:0, nextSpawnAt:0, cooldownUntil:0 }, 
        beetleAttack: { phase:'idle', announceUntil:0, endsAt:0, nextSpawnAt:0, cooldownUntil:0 },
        globalEventLockUntil: 0,
        beetleRollbackCD: {},
        damageReports: []
      },
      lastActiveAt: Date.now(),
      upgrades: { EnergyCap: 0, Storage: 0, EnergyRegen: 0, PlotSlots: 0 }, shop: rollShopStock(),
    });

    const generateOrders = (count) => Array.from({ length: count }, (_, i) => { const reqItem1 = Object.keys(CROP_DATA)[randInt(0, Object.keys(CROP_DATA).length-1)]; const reqQty1 = 5 + randInt(0,5); const reward = Math.floor(CROP_DATA[reqItem1].basePrice * reqQty1 * rand(1.5, 2)); return { id: `order-${Date.now()}-${i}`, requires: [{ item: reqItem1, qty: reqQty1 }], rewardCoins: reward, rewardGems: Math.random() < 0.1 ? 1 : undefined, expiresAt: Date.now() + rand(8, 18) * 60 * 1000 }; });
    
    function App() {
      const playAreaRef = useRef(null);
      const [gameState, setGameState] = useState(() => {
        try {
          const saved = localStorage.getItem(SAVE_KEY);
          let state = saved ? JSON.parse(saved) : createInitialState();
          
          state.maxPlots = state.maxPlots ?? 6;
          if (state.plots.length < state.maxPlots) { for (let i = state.plots.length; i < state.maxPlots; i++) { state.plots.push({ id: `plot-${i}` }); } }
          state.shop = state.shop ?? rollShopStock();
          state.upgrades = state.upgrades ?? { EnergyCap: 0, Storage: 0, EnergyRegen: 0, PlotSlots: 0 };
          state.inv.seeds = state.inv.seeds ?? {};
          state.inv.items = state.inv.items ?? {Fertilizer:0, PestControl:0};
          state.world = state.world ?? {};
          state.world.bugs = state.world.bugs ?? [];
          state.world.beetles = state.world.beetles ?? state.world.bees ?? [];
          state.world.bugAttack = state.world.bugAttack ?? { phase:'idle', announceUntil:0, endsAt:0, nextSpawnAt:0, cooldownUntil:0 };
          state.world.beetleAttack = state.world.beetleAttack ?? state.world.beeAttack ?? { phase:'idle', announceUntil:0, endsAt:0, nextSpawnAt:0, cooldownUntil:0 };
          state.world.globalEventLockUntil = state.world.globalEventLockUntil ?? 0;
          state.world.beetleRollbackCD = state.world.beetleRollbackCD ?? {};
          state.world.damageReports = state.world.damageReports ?? [];

          const now = Date.now();
          const dt = Math.min(now - state.lastActiveAt, OFFLINE_CAP_HOURS * 3600 * 1000);
          const energyGained = Math.floor(dt / 60000 * state.eco.energy.regenPerMinute);
          if (energyGained > 0) { state.eco.energy.current = Math.min(state.eco.energy.max, state.eco.energy.current + energyGained); state.eco.energy.lastRefill = now; }
          state.lastActiveAt = now;
          return state;
        } catch(e) { console.error("Failed to load state, resetting.", e); return createInitialState(); }
      });
      
      const [activeTab, setActiveTab] = useState('Plant');
      const [selectedSeed, setSelectedSeed] = useState('Carrot');
      const [toast, setToast] = useState(null);
      const [now, setNow] = useState(Date.now());
      const [floaters, setFloaters] = useState([]);
      const [coinsAnimKey, setCoinsAnimKey] = useState(0);
      const [damageBanners, setDamageBanners] = useState([]);
      const [lockedOrders, setLockedOrders] = useState({});

      useEffect(() => {
        const reports = gameState.world?.damageReports || [];
        if (!reports.length) return;

        setDamageBanners(prev => [...prev, ...reports]);

        setGameState(prev => {
          const ns = JSON.parse(JSON.stringify(prev));
          ns.world.damageReports = [];
          return ns;
        });

        reports.forEach(r => {
          setTimeout(() => {
            setDamageBanners(prev => prev.filter(b => b.id !== r.id));
          }, 10000);
        });
      }, [gameState.world?.damageReports?.length]);

      const addFloater = (x, y, text) => {
        const id = Math.random().toString(36).slice(2);
        setFloaters(fs => [...fs, { id, x, y, text }]);
        setTimeout(() => setFloaters(fs => fs.filter(f => f.id !== id)), 900);
      };

      function getPlotUnderXYPercent(xPct, yPct) {
        const layer = document.querySelector('.bug-layer');
        const plots = Array.from(document.querySelectorAll('.plot-cell'));
        if (!layer || plots.length === 0) return null;
        const layerRect = layer.getBoundingClientRect();
        const x = layerRect.left + (xPct / 100) * layerRect.width;
        const y = layerRect.top  + (yPct / 100) * layerRect.height;
        let best = null, bestArea = 0;
        for (const cell of plots) {
          const r = cell.getBoundingClientRect();
          if (x >= r.left && x <= r.right && y >= r.top && y <= r.bottom) {
            const area = (r.right - r.left) * (r.bottom - r.top);
            if (area > bestArea) { best = cell; bestArea = area; }
          }
        }
        return best?.getAttribute('data-plot-id') || null;
      }

      useEffect(() => { localStorage.setItem(SAVE_KEY, JSON.stringify(gameState)); }, [gameState]);
      const showToast = useCallback((message, isError = false) => { setToast(message); if (isError) haptic('error'); setTimeout(() => setToast(null), 3000); }, []);

      useEffect(() => {
        let rafId;
        let last = performance.now();

        const animate = (t) => {
          const dt = Math.max(0, (t - last) / 1000); // сек
          last = t;
          setNow(Date.now());

          setGameState(prev => {
            const w = prev.world;

            const immUpdate = (list) => list
              .map(ent => {
                const nx = ent.x + ent.vx * dt;
                const ny = clamp(ent.y + (Math.random() - 0.5) * 0.5, 2, 98);
                return { ...ent, x: nx, y: ny };
              })
              .filter(ent =>
                performance.now() < ent.expiresAt && ent.x > -15 && ent.x < 115
              );

            const bugs = immUpdate(w.bugs);
            const beetles = immUpdate(w.beetles);

            if (w.bugs === bugs && w.beetles === beetles) return prev;
            return { ...prev, world: { ...w, bugs, beetles } };
          });

          rafId = requestAnimationFrame(animate);
        };

        rafId = requestAnimationFrame(animate);
        return () => cancelAnimationFrame(rafId);
      }, []);


      useEffect(() => {
        const gameTimer = setInterval(() => {
          const currentNow = Date.now();
          setGameState(prev => {
              const newState = JSON.parse(JSON.stringify(prev));
              const dtSec = (currentNow - newState.lastActiveAt) / 1000;
              
              if ((newState.shop?.nextRefresh ?? 0) <= currentNow) newState.shop = rollShopStock();
              if ((newState.eco.hotPrice?.endsAt ?? 0) <= currentNow) newState.eco.hotPrice = null;
              if (newState.world.heatwaveUntil && newState.world.heatwaveUntil <= currentNow) newState.world.heatwaveUntil = 0;
              
              const energyDt = currentNow - newState.eco.energy.lastRefill;
              const energyGained = Math.floor(energyDt / 60000 * newState.eco.energy.regenPerMinute);
              if (energyGained > 0) { newState.eco.energy.current = Math.min(newState.eco.energy.max, newState.eco.energy.current + energyGained); newState.eco.energy.lastRefill += energyGained * (60000 / newState.eco.energy.regenPerMinute); }

              newState.orders = (newState.orders || []).filter(o => o.expiresAt > currentNow);
              if ((newState.orders || []).length < 3 && (newState.world.nextOrderAt || 0) <= currentNow) { newState.orders.push(...generateOrders(1)); newState.world.nextOrderAt = currentNow + rand(60,120)*1000; }
              if (currentNow - (newState.world.lastOrdersUpdate || 0) >= Ticks.ORDERS) { if (Math.max(0, 3 - newState.orders.length) > 0) newState.orders.push(...generateOrders(1)); newState.world.lastOrdersUpdate = currentNow; }
              if (currentNow - (newState.world.lastWeatherUpdate || 0) >= Ticks.WEATHER) { newState.world.weather = ['Sunny', 'Rainy', 'Cloudy'][randInt(0,2)]; newState.world.lastWeatherUpdate = currentNow; if (newState.world.weather === 'Sunny' && Math.random() < 0.35) { newState.world.heatwaveUntil = currentNow + rand(90,180)*1000; } }
              
              const handleAttack = (type) => {
                if (plantedCount(newState) < 2) return;

                const otherKey = (type === 'bug') ? 'beetleAttack' : 'bugAttack';
                const other = newState.world[otherKey];
                if (other.phase === 'announce' || other.phase === 'active') return;
                if (currentNow < newState.world.globalEventLockUntil) return;

                const nodeKey = type === 'bug' ? 'bugAttack' : 'beetleAttack';
                const listKey = type === 'bug' ? 'bugs' : 'beetles';
                const A = newState.world[nodeKey];

                switch (A.phase) {
                  case 'idle': {
                    if (currentNow > A.cooldownUntil && Math.random() < 0.12 && currentNow >= newState.world.globalEventLockUntil) {
                      A.phase = 'announce';
                      A.announceUntil = currentNow + rand(3000, 5000);
                      newState.world.globalEventLockUntil = currentNow + rand(6000, 10000);
                    }
                    break;
                  }
                  case 'announce': {
                    if (currentNow >= A.announceUntil) {
                      A.phase = 'active';
                      A.endsAt = currentNow + rand(25000, 45000);
                      A.nextSpawnAt = currentNow;
                      A.loot = {
                        coinsLeft: randInt(INSECT_LOOT.budget.coinsMin, INSECT_LOOT.budget.coinsMax),
                        energyLeft: randInt(INSECT_LOOT.budget.energyMin, INSECT_LOOT.budget.energyMax),
                        gemsLeft: randInt(INSECT_LOOT.budget.gemsMin, INSECT_LOOT.budget.gemsMax),
                      };
                      A.stats = { waterLost: 0, fertLost: 0, freezeMs: 0, rollback: 0, affected: {} };
                    }
                    break;
                  }
                  case 'active': {
                    if (currentNow >= A.endsAt) {
                      A.phase = 'drain';
                      A.drainStartedAt = currentNow;
                    } else if (currentNow >= A.nextSpawnAt) {
                      const list = newState.world[listKey];
                      if (list.length < INSECT_CAP[type]) {
                        const freeSlots = Math.max(0, INSECT_CAP[type] - list.length);
                        const wave = Math.min(freeSlots, randInt(1, 2));
                        const fastQuota = randInt(0, 1);

                        for (let i = 0; i < wave; i++) {
                          const size = rand(INSECT_TUNING.sizeMinPct, INSECT_TUNING.sizeMaxPct);
                          const y = visibleYPct(playAreaRef.current);
                          const isFast = i < fastQuota;
                          const base = (type === 'bug')
                            ? (isFast ? rand(14, 20) : rand(5, 10))
                            : (isFast ? rand(15, 22) : rand(6, 12));
                          const speed = base * INSECT_TUNING.speedScale;
                          const x = (type === 'bug') ? -12 : 112;
                          const vx = (type === 'bug') ? +speed : -speed;

                          list.push({
                            id: `${currentNow}-${i}-${Math.random()}`, type, x, y, vx, vy: 0, size,
                            expiresAt: currentNow + rand(7000, 12000),
                            dwellOnPlotMs: 0, lastPlotId: null,
                            currentPlotId: null, dwellOnThisPlotMs: 0
                          });
                        }
                      }
                      A.nextSpawnAt = currentNow + rand(1400, 3800);
                    }
                    break;
                  }
                }
              };

              handleAttack('bug');
              handleAttack('beetle');

              const finalizeWave = (typeKey, listKey) => {
                const A = newState.world[typeKey];
                if (A.phase === 'drain' && newState.world[listKey].length === 0) {
                  if (A.stats) {
                    const isBug = (typeKey === 'bugAttack');
                    const w  = (A.stats.waterLost || 0).toFixed(2);
                    const f  = (A.stats.fertLost  || 0).toFixed(2);
                    const fr = ((A.stats.freezeMs || 0) / 1000).toFixed(2);
                    const rbPct = ((A.stats.rollback || 0) * 100).toFixed(2);
                    const affected = A.stats.affected ? Object.keys(A.stats.affected).length : 0;
                    const avgFreeze = affected ? ((A.stats.freezeMs/1000) / affected).toFixed(2) : '0.00';

                    const text = isBug
                      ? `🐛 Нанесенный ущерб: -${w} воды, -${f} удобр. · Затронуто растений ${affected}`
                      : `🪲 Нанесенный ущерб: замедлено растений ${affected} примерно на ${avgFreeze} сек · Откат прогресса -${rbPct}%`;

                    newState.world.damageReports.push({
                      id: `dmg-${isBug ? 'bug' : 'beetle'}-${currentNow}-${Math.random()}`,
                      type: isBug ? 'bug' : 'beetle',
                      text,
                      stats: A.stats
                    });
                    A.stats = null;
                  }

                  A.phase = 'idle';
                  A.cooldownUntil = currentNow + rand(50000, 120000);
                  const bigGap = Math.random() < 0.5;
                  newState.world.globalEventLockUntil = currentNow + (bigGap ? rand(120000, 300000) : rand(20000, 45000));
                }
              };

              finalizeWave('bugAttack', 'bugs');
              finalizeWave('beetleAttack', 'beetles');

              const beetleCD = newState.world.beetleRollbackCD || (newState.world.beetleRollbackCD = {});
              const lists = [
                { type: 'bug', list: newState.world.bugs },
                { type: 'beetle', list: newState.world.beetles }
              ];
              for (const L of lists) {
                for (const ent of L.list) {
                  const pid = getPlotUnderXYPercent(ent.x, ent.y);

                  if (!pid) {
                    if (L.type === 'beetle' && ent.currentPlotId && ent.dwellOnThisPlotMs >= DAMAGE_TUNING.beetle.minDwellForRollbackSec*1000) {
                      const plotId = ent.currentPlotId;
                      const cdUntil = beetleCD[plotId] || 0;
                      if (currentNow >= cdUntil) {
                        const pIdx = newState.plots.findIndex(p=>p.id===plotId);
                        if (pIdx >= 0) {
                          const crop = newState.plots[pIdx].crop;
                          if (crop) {
                            const beforeP = crop.progress;
                            const stageFloor = (crop.progress < 0.5) ? 0 : 0.5;
                            crop.progress = clamp(crop.progress - DAMAGE_TUNING.beetle.leaveRollback, stageFloor, 1);
                            const deltaP = Math.max(0, beforeP - crop.progress);
                            
                            const BEA2 = newState.world.beetleAttack;
                            (BEA2.stats ||= { waterLost:0, fertLost:0, freezeMs:0, rollback:0, affected: {} });
                            BEA2.stats.rollback += deltaP;
                            BEA2.stats.affected[plotId] = true;

                            if (crop.stage === 'Mature' && crop.progress < 1)
                              crop.stage = (crop.progress >= 0.5) ? 'Sprout' : 'Seed';
                            beetleCD[plotId] = currentNow + DAMAGE_TUNING.beetle.rollbackCooldownSec*1000;
                          }
                        }
                      }
                    }
                    ent.lastPlotId = ent.currentPlotId;
                    ent.currentPlotId = null;
                    ent.dwellOnThisPlotMs = 0;
                    continue;
                  }
                  
                  ent.lastPlotId = pid;
                  if (ent.currentPlotId !== pid) {
                    ent.currentPlotId = pid;
                    ent.dwellOnThisPlotMs = 0;
                  }

                  const pIdx = newState.plots.findIndex(p=>p.id===pid);
                  if (pIdx < 0) continue;
                  const plot = newState.plots[pIdx];
                  if (!plot.crop) continue;

                  ent.dwellOnPlotMs = (ent.dwellOnPlotMs || 0) + 1000;
                  ent.dwellOnThisPlotMs = (ent.dwellOnThisPlotMs || 0) + 1000;

                  if (L.type === 'bug') {
                    const beforeW = plot.crop.water;
                    const beforeF = plot.crop.fertilizer;
                    const mul = (plot.crop.shieldUntil && currentNow < plot.crop.shieldUntil) ? DAMAGE_TUNING.bug.shieldMultiplier : 1;
                    const dw = DAMAGE_TUNING.bug.waterPerSec * mul;
                    const df = DAMAGE_TUNING.bug.fertPerSec * mul;
                    plot.crop.water = clamp(plot.crop.water - dw, 0, 100);
                    plot.crop.fertilizer = clamp(plot.crop.fertilizer - df, 0, 100);
                    const effW = Math.max(0, beforeW - plot.crop.water);
                    const effF = Math.max(0, beforeF - plot.crop.fertilizer);
                    const BA = newState.world.bugAttack;
                    (BA.stats ||= { waterLost:0, fertLost:0, freezeMs:0, rollback:0, affected: {} });
                    BA.stats.waterLost += effW;
                    BA.stats.fertLost  += effF;
                    BA.stats.affected[pid] = true;
                  } else { // beetle
                    const oldFrozen = plot.crop.frozenUntil || 0;
                    const extendMs = DAMAGE_TUNING.beetle.freezeExtendSec * 1000;
                    const newFrozen = Math.max(oldFrozen, currentNow + extendMs);
                    plot.crop.frozenUntil = newFrozen;

                    const added = Math.max(0, newFrozen - oldFrozen);
                    const BEA = newState.world.beetleAttack;
                    (BEA.stats ||= { waterLost:0, fertLost:0, freezeMs:0, rollback:0, affected: {} });
                    BEA.stats.freezeMs += added;
                    BEA.stats.affected[pid] = true;
                  }
                }
              }
              
              newState.plots.forEach((plot) => {
                  if (plot.crop) {
                      const cropData = CROP_DATA[plot.crop.type];
                      let growthSpeedModifier = growthSpeedMul(plot.crop, newState.world, currentNow);
                      if (plot.crop.progress < 1) {
                          const speed = growthSpeedModifier;
                          plot.crop.progress = clamp(plot.crop.progress + dtSec / cropData.growTime * speed, 0, 1);
                          plot.crop.stage = plot.crop.progress >= 0.5 ? 'Sprout' : 'Seed';
                      } else { if (plot.crop.stage !== 'Mature') { plot.crop.stage = 'Mature'; plot.crop.harvestYield = calculateYield(plot.crop); } }
                  }
              });

              const attackedMap = {};
              for (const ent of newState.world.bugs) {
                if (ent.currentPlotId) {
                  attackedMap[ent.currentPlotId] ||= { bug:0, beetle:0 };
                  attackedMap[ent.currentPlotId].bug++;
                }
              }
              for (const ent of newState.world.beetles) {
                if (ent.currentPlotId) {
                  attackedMap[ent.currentPlotId] ||= { bug:0, beetle:0 };
                  attackedMap[ent.currentPlotId].beetle++;
                }
              }
              newState.world.attackedMap = attackedMap;
              
              newState.lastActiveAt = currentNow;
              return newState;
          });
        }, Ticks.GAME);
        return () => clearInterval(gameTimer);
      }, []);

      const spendEnergy = (amount) => { if (gameState.eco.energy.current < amount) { showToast("Недостаточно энергии! ⚡", true); return false; } setGameState(prev => ({ ...prev, eco: { ...prev.eco, energy: { ...prev.eco.energy, current: prev.eco.energy.current - amount } } })); return true; }
      const handlePlotClick = (plot) => { if (plot.crop?.stage === 'Mature') handleHarvest(plot.id); else if (!plot.crop) handlePlant(plot.id); }
      
      function previewInsectLoot(kind, state) {
        const nodeKey = kind === 'bug' ? 'bugAttack' : 'beetleAttack';
        const A = state.world?.[nodeKey];
        if (!A?.loot) return { coins: 0, energy: 0, gems: 0 };

        let coins = 0, energy = 0, gems = 0;

        if (A.loot.coinsLeft > 0 && Math.random() < INSECT_LOOT.coinChance) {
          const drop = randInt(INSECT_LOOT.coinPerKillMin, INSECT_LOOT.coinPerKillMax);
          coins = Math.min(drop, A.loot.coinsLeft);
        }
        if (A.loot.energyLeft > 0 && Math.random() < INSECT_LOOT.energyChance) {
          energy = 1;
        }
        if (A.loot.gemsLeft > 0 && Math.random() < INSECT_LOOT.gemChance) {
          gems = 1;
        }
        return { coins, energy, gems };
      }

      const handleInsectClick = (evt, kind, id) => {
        haptic('success');
        const tapX = evt.clientX;
        const tapY = evt.clientY;

        const normalized = (kind === 'bee') ? 'beetle' : kind;
        const lootPreview = previewInsectLoot(normalized, gameState);

        setGameState(prev => {
          const ns = JSON.parse(JSON.stringify(prev));
          const listKey = normalized === 'bug' ? 'bugs' : 'beetles';
          const list = ns.world[listKey] || [];
          const ent = list.find(i => i.id === id);
          let pid = null;
          if (ent) pid = getPlotUnderXYPercent(ent.x, ent.y);

          ns.world[listKey] = list.filter(i => i.id !== id);

          if (pid) {
            const idx = ns.plots.findIndex(p=>p.id===pid);
            if (idx >= 0) {
              const crop = ns.plots[idx].crop;
              if (crop) {
                if (normalized === 'bug') {
                  const target = (crop.water <= crop.fertilizer) ? 'water' : 'fertilizer';
                  crop[target] = clamp(crop[target] + COMPENSATION.bugHealPct, 0, 100);
                } else {
                  const nowTs = Date.now();
                  crop.frozenUntil = 0;
                  if ((crop.growthBuffStacks || 0) < COMPENSATION.beetleBuff.maxStacks) {
                    crop.growthBuffStacks = (crop.growthBuffStacks || 0) + 1;
                  }
                  crop.growthBuffUntil = Math.max(crop.growthBuffUntil || 0, nowTs + COMPENSATION.beetleBuff.durationMs);
                }
              }
            }
          }

          const A = ns.world[normalized === 'bug' ? 'bugAttack' : 'beetleAttack'];
          if (A?.loot) {
            const coinsToAdd  = Math.min(lootPreview.coins,  A.loot.coinsLeft || 0);
            const energyToAdd = Math.min(lootPreview.energy, A.loot.energyLeft || 0);
            const gemsToAdd   = Math.min(lootPreview.gems,   A.loot.gemsLeft || 0);

            if (coinsToAdd > 0) { ns.eco.coins += coinsToAdd; A.loot.coinsLeft  -= coinsToAdd; }
            if (energyToAdd > 0) { ns.eco.energy.current = Math.min(ns.eco.energy.max, ns.eco.energy.current + energyToAdd); A.loot.energyLeft -= energyToAdd; }
            if (gemsToAdd > 0) { ns.eco.gems += gemsToAdd; A.loot.gemsLeft -= gemsToAdd; }

            if (coinsToAdd > 0) setCoinsAnimKey(k => k + 1);
          }

          return ns;
        });

        const parts = [];
        if (lootPreview.coins > 0) parts.push(`+${lootPreview.coins}💰`);
        if (lootPreview.energy > 0) parts.push('+⚡');
        if (lootPreview.gems > 0) parts.push('+💎');
        if (parts.length > 0) addFloater(tapX, tapY, parts.join(' '));
      };

      const handlePlant = (plotId) => {
        const seedType = selectedSeed;
        if ((gameState.inv.seeds[seedType] || 0) < 1) { showToast(`Купите семена ${CROP_DATA[seedType].name} в Shop`, true); return; }
        if (!spendEnergy(1)) return;
        haptic('success');
        setGameState(prev=>{
          const idx = prev.plots.findIndex(p=>p.id===plotId);
          if (idx<0 || prev.plots[idx].crop) return prev;
          const next = JSON.parse(JSON.stringify(prev));
          next.plots[idx].crop = { 
            type: seedType, plantedAt: Date.now(), stage:'Seed', progress:0, 
            water: randInt(45,60), fertilizer: randInt(40,55), quality:1.0, 
            plotId, waterBoostUntil:0, fertBoostUntil:0,
            frozenUntil: 0, growthBuffUntil: 0, growthBuffStacks: 0
          };
          next.inv.seeds[seedType] = Math.max(0, (next.inv.seeds[seedType]||0) - 1);
          return next;
        });
      };

      const handleHarvest = (plotId) => {
          const plot = gameState.plots.find(p => p.id === plotId);
          if (!plot?.crop || plot.crop.stage !== 'Mature' || !spendEnergy(1)) return;
          let baseYield = plot.crop.harvestYield ?? calculateYield(plot.crop);
          const bonus = (plot.crop.shieldUntil && Date.now() < plot.crop.shieldUntil) ? Math.floor(baseYield * 0.1) : 0;
          const yieldCount = baseYield + bonus;
          haptic('success');
          setGameState(prev => ({...prev, plots: prev.plots.map(p => p.id === plotId ? { ...p, crop: undefined } : p), inv: {...prev.inv, raw: {...prev.inv.raw, [plot.crop.type]: (prev.inv.raw[plot.crop.type] || 0) + yieldCount }}, }));
          showToast(`Собрано ${CROP_DATA[plot.crop.type].name} x${yieldCount}`);
      }

      const handleCareFor = (plotId, action) => {
          if (action === 'water') {
            if(!spendEnergy(1)) return; haptic('light');
            setGameState(prev => ({...prev, plots: prev.plots.map(p => (p.id===plotId && p.crop) ? {...p, crop:{...p.crop, water: clamp(p.crop.water+25,0,100), waterBoostUntil: Date.now() + 15000 }} : p)}));
          } else if (action === 'fertilize') {
            if ((gameState.inv.items.Fertilizer || 0) < 1) { showToast("Нет удобрений", true); return; }
            if (!spendEnergy(2)) return; haptic('light');
            setGameState(prev => ({...prev, plots: prev.plots.map(p => (p.id===plotId && p.crop) ? {...p, crop:{...p.crop, fertilizer: clamp(p.crop.fertilizer+25,0,100), fertBoostUntil: Date.now() + 15000 }} : p), inv: {...prev.inv, items: {...prev.inv.items, Fertilizer: prev.inv.items.Fertilizer - 1}}}));
          } else if (action === 'shield') {
            if ((gameState.inv.items.PestControl || 0) < 1) { showToast("Нет защиты", true); return; }
            if (!spendEnergy(1)) return; haptic('light');
            setGameState(prev => ({...prev, plots: prev.plots.map(p => (p.id === plotId && p.crop) ? {...p, crop: {...p.crop, shieldUntil: Date.now() + 10 * 60 * 1000 }} : p), inv: {...prev.inv, items: {...prev.inv.items, PestControl: prev.inv.items.PestControl - 1}}}));
          } 
      }

      const handleBuy = (type, key) => {
        const level = gameState.upgrades[key] || 0;
        const cost = type === 'seed' ? CROP_DATA[key].seedPrice : type === 'item' ? (key === 'Fertilizer' ? 5 : 8) : UPGRADE_DATA[key].baseCost + UPGRADE_DATA[key].costScale * level;
        if (gameState.eco.coins < cost) { showToast("Недостаточно монет!", true); return; }
        const stockInfo = (gameState.shop?.stock || {})[key];
        if (type === 'seed' && (!stockInfo?.available || stockInfo.qty <= 0)) { showToast('Нет в продаже', true); return; }
        
        haptic('success');
        setGameState(prev => {
          const ns = JSON.parse(JSON.stringify(prev));
          ns.eco.coins -= cost;
          if (type === 'seed') { ns.shop.stock[key].qty--; if (ns.shop.stock[key].qty === 0) ns.shop.stock[key].available = false; ns.inv.seeds[key] = (ns.inv.seeds[key] || 0) + 1; } 
          else if (type === 'item') { ns.inv.items[key] = (ns.inv.items[key] || 0) + 1; } 
          else if (type === 'upgrade') { ns.upgrades[key] = (ns.upgrades[key] || 0) + 1; if (key === 'EnergyCap') ns.eco.energy.max += 5; else if (key === 'EnergyRegen') ns.eco.energy.regenPerMinute += 0.5; else if (key === 'PlotSlots' && ns.maxPlots < 16) { ns.maxPlots++; ns.plots.push({ id: `plot-${ns.plots.length}` }); } }
          return ns;
        });
        showToast("Покупка совершена!");
      };

      const handleSell = (item, amount) => {
          const have = gameState.inv.raw[item] || 0;
          const qty = amount === 'one' ? 1 : have;
          if (qty <= 0) return;
          let priceMultiplier = gameState.eco.marketTrend[item] || 1;
          if(gameState.eco.hotPrice?.crop === item) { priceMultiplier *= gameState.eco.hotPrice.multiplier; }
          const price = Math.max(0, Math.floor(CROP_DATA[item].basePrice * priceMultiplier));
          haptic('success');
          setGameState(prev => ({...prev, eco: {...prev.eco, coins: prev.eco.coins + (price * qty)}, inv: {...prev.inv, raw: {...prev.inv.raw, [item]: have - qty}} }));
          showToast(`Продано на ${price * qty}💰`);
          setCoinsAnimKey(k => k + 1);
      }
      
      const handleFulfillOrder = (order) => {
        if (lockedOrders[order.id]) return;
        if (!order.requires.every(req => (gameState.inv.raw[req.item] || 0) >= req.qty)) {
          showToast("Недостаточно ресурсов!", true);
          return;
        }

        setLockedOrders(prev => ({ ...prev, [order.id]: true }));
        haptic('success');

        setGameState(prev => {
          const ns = JSON.parse(JSON.stringify(prev));
          if (!(ns.orders || []).some(o => o.id === order.id)) return prev;

          order.requires.forEach(req => { ns.inv.raw[req.item] -= req.qty; });
          ns.eco.coins += order.rewardCoins;
          if (order.rewardGems) ns.eco.gems += order.rewardGems;
          ns.orders = ns.orders.filter(o => o.id !== order.id);
          return ns;
        });

        showToast(`Заказ выполнен! +${order.rewardCoins}💰`);
        setCoinsAnimKey(k => k + 1);
      };
      
      const { eco, inv, plots, world, shop, upgrades } = gameState;
      const hot = eco.hotPrice;

      return (
        <React.Fragment>
          {toast && <div className="toast bg-blue-500 text-white px-6 py-2 rounded-full shadow-lg animate-bounce">{toast}</div>}
          {floaters.map(f => (
            <div key={f.id} className="floater" style={{ left: f.x, top: f.y }}>
              {f.text}
            </div>
          ))}
          
          <div className="hud">
            <div className="hud-events">
              {hot && <div className="event-card hot-pulse"><span className="font-bold">🔥 HOT: {CROP_DATA[hot.crop].icon} x{hot.multiplier.toFixed(2)}</span><span className="block text-[10px] opacity-80">{fmtMMSS((hot.endsAt - now)/1000)}</span></div>}
              {world.heatwaveUntil > now && <div className="event-card heat-pulse"><span className="font-bold">☀️ HEAT</span><span className="block text-[10px] opacity-90">{fmtMMSS((world.heatwaveUntil - now)/1000)}</span></div>}
              {world.attackedMap && Object.keys(world.attackedMap).length > 0 && (
                <div className="event-card">
                  Грядки под атакой: {Object.keys(world.attackedMap).length}
                </div>
              )}
              {damageBanners.map(b => (
                <div key={b.id} className="event-card damage-banner">
                  <div className="title">{b.text}</div>
                  <div className="damage-bar"><span /></div>
                </div>
              ))}
            </div>
            <div className="hud-resources">
              <div className={`bg-yellow-400 text-yellow-900 font-bold px-3 py-1 rounded-full shadow-md ${coinsAnimKey ? 'coins-bounce' : ''}`}>💰 {eco.coins}</div>
              <div className="bg-purple-400 text-purple-900 font-bold px-3 py-1 rounded-full shadow-md">💎 {eco.gems}</div>
              <div className="bg-blue-300 text-blue-900 font-bold px-3 py-1 rounded-full shadow-md leading-tight flex flex-col items-end">
                <span>⚡ {eco.energy.current}/{eco.energy.max}</span>
                <span className="energy-timer">{eco.energy.current >= eco.energy.max ? 'Full' : `+1 in ${fmtMMSS(energySecondsToNext(eco.energy, now))}`}</span>
              </div>
              
              {(world.bugAttack.phase === 'announce' || world.bugAttack.phase === 'active' || world.bugAttack.phase === 'drain') && (
                <div title="Атака гусениц" className="bg-black/20 text-white rounded-full px-2 py-1 flex items-center gap-1">
                  <img src="https://raw.githubusercontent.com/Poklontsevv/growgarden/main/caterpillar.png"
                       alt="caterpillar" style={{ width: 20, height: 20 }} />
                  <span className="text-[11px]">
                    {world.bugAttack.phase === 'announce'
                      ? fmtMMSS(Math.ceil((world.bugAttack.announceUntil - now)/1000))
                      : fmtMMSS(Math.ceil((world.bugAttack.endsAt - now)/1000))}
                  </span>
                </div>
              )}

              {(world.beetleAttack.phase === 'announce' || world.beetleAttack.phase === 'active' || world.beetleAttack.phase === 'drain') && (
                <div title="Атака жуков" className="bg-black/20 text-white rounded-full px-2 py-1 flex items-center gap-1">
                  <img src={ENEMY_IMG_BEETLE} alt="beetle" style={{ width: 20, height: 20 }} />
                  <span className="text-[11px]">
                    {world.beetleAttack.phase === 'announce'
                      ? fmtMMSS(Math.ceil((world.beetleAttack.announceUntil - now)/1000))
                      : fmtMMSS(Math.ceil((world.beetleAttack.endsAt - now)/1000))}
                  </span>
                </div>
              )}
            </div>
          </div>

          <div className="app-container text-gray-800 font-sans">
              <div className="play-area" ref={playAreaRef}>
                  <div className="plots-wrap">
                    <div className="bug-layer">
                      {[...(world.bugs || []), ...(world.beetles || [])].map(ent => (
                        <span
                          key={ent.id}
                          className="bug"
                          style={{ left: `${ent.x}%`, top: `${ent.y}%`, width: `${ent.size}%`, height: `${ent.size}%` }}
                          onPointerDown={(e) => { e.stopPropagation(); handleInsectClick(e, ent.type, ent.id); }}
                        >
                          {ent.type === 'bug'
                             ? (<img className="bug-sprite" alt="caterpillar" src="https://raw.githubusercontent.com/Poklontsevv/growgarden/main/caterpillar.png" />)
                             : (<img className="beetle-sprite" alt="beetle" src={ENEMY_IMG_BEETLE} />)}
                        </span>
                      ))}
                    </div>

                    <div className="plots">
                      {plots.map(plot => {
                        const atk = world.attackedMap?.[plot.id];
                        const isAttacked = !!atk && ((atk.bug||0)+(atk.beetle||0) > 0);
                        return (
                          <div key={plot.id} className="plot-cell" data-plot-id={plot.id}>
                            {plot.crop && plot.crop.stage !== 'Mature' && (
                              <div className="plot-toolbar">
                                <button
                                  className="toolbar-btn"
                                  title="Полить 1⚡"
                                  onClick={(e)=>{ e.stopPropagation(); handleCareFor(plot.id,'water'); }}>
                                  <img className="ui-icon" alt="Полив" src={ICONS.water} />
                                </button>

                                <button
                                  className="toolbar-btn"
                                  title="Удобрить 2⚡"
                                  onClick={(e)=>{ e.stopPropagation(); handleCareFor(plot.id,'fertilize'); }}>
                                  <img className="ui-icon" alt="Удобрение" src={ICONS.fertilizer} />
                                </button>

                                <button
                                  className="toolbar-btn"
                                  title="Защита 1⚡"
                                  onClick={(e)=>{ e.stopPropagation(); handleCareFor(plot.id,'shield'); }}>
                                  <img className="ui-icon" alt="Защита" src={ICONS.protect} />
                                </button>
                              </div>
                            )}

                            <div
                              onClick={() => handlePlotClick(plot)}
                              className={`plot cursor-pointer transition-all duration-200
                                ${world.heatwaveUntil > now && plot.crop ? 'plot--heated' : ''}
                                ${hot?.crop === plot.crop?.type ? 'plot--hot' : ''}
                                ${isAttacked ? 'plot--attacked' : ''}`}
                            >
                               {isAttacked && (
                                <div className="plot-attack-icons">
                                  {atk.bug ? `🐛x${atk.bug} ` : ''}{atk.beetle ? `🪲x${atk.beetle}` : ''}
                                </div>
                              )}
                              {plot.crop && plot.crop.stage !== 'Mature' && (
                                <div className="plot-timer">
                                  {fmtMMSS(secondsToNextStage(plot.crop, world))}
                                  {now < (plot.crop.frozenUntil || 0) && <span> ❄️</span>}
                                </div>
                              )}
                              
                              {plot.crop ? (
                                <>
                                  {plot.crop.shieldUntil && now < plot.crop.shieldUntil && (<span className="absolute top-1 left-1 text-base z-10">🛡️</span>)}
                                  <div className={`h-full w-full ${plot.crop.stage !== plot.prevStage ? 'stage-pop' : ''}`}> <div className="plot-figure"> {stageIcon(plot.crop.type, plot.crop.stage)} </div> </div>
                                  {plot.crop.stage === 'Mature' && (<> <div className="absolute top-1 text-xs font-bold text-green-200 bg-black/30 px-2 rounded-full"> x{plot.crop.harvestYield ?? calculateYield(plot.crop)} </div> <div className="absolute inset-x-0 bottom-6 text-center"> <span className="inline-block text-[11px] px-2 py-0.5 rounded-full bg-black/35 text-white"> Tap to harvest </span> </div> </>)}
                                  <div className="absolute bottom-1 left-1 right-1 flex flex-col gap-0.5">
                                    <div className="h-1.5 bg-black/20 rounded-full status-bar-div"><div style={{width:`${plot.crop.water}%`}} className="h-full bg-blue-400 rounded-full"></div></div>
                                    <div className="h-1.5 bg-black/20 rounded-full status-bar-div"><div style={{width:`${plot.crop.fertilizer}%`}} className="h-full bg-orange-400 rounded-full"></div></div>
                                  </div>
                                </>
                              ) : ( <div className="text-gray-400 text-xs text-center">Пусто</div> )}
                            </div>
                          </div>
                        )})}
                    </div>
                  </div>
              </div>
          </div>
          <div className="bottom-panel p-2 text-white">
              <div className="flex justify-center gap-1 mb-2">{(['Plant', 'Shop', 'Orders', 'Inventory']).map(tab => <button key={tab} onClick={() => setActiveTab(tab)} className={`px-2 py-1 text-xs rounded-t-lg ${activeTab === tab ? 'bg-yellow-600 font-bold' : 'bg-yellow-900'}`}>{tab}</button>)}</div>
              <div className="panel-scroll bg-yellow-600 rounded-lg p-2 text-xs">
                  {activeTab === 'Plant' && <div><h3 className="text-center font-bold mb-1">Посадка</h3><div className="grid grid-cols-4 sm:grid-cols-5 gap-1 bg-black/20 p-1 rounded-md mb-2">{Object.entries(CROP_DATA).map(([key, c]) => (<button key={key} onClick={() => setSelectedSeed(key)} className={`p-1 rounded text-center flex flex-col items-center justify-center ${selectedSeed === key ? 'bg-green-500' : ''}`} title={`${c.name} (у вас: ${inv.seeds[key] || 0})`}><img className="seed-icon" src={CROP_ICON_URL[key]} alt={c.name} /><span className="block text-[10px]">x{inv.seeds[key] || 0}</span></button>))}</div>
                      <div className="flex justify-center gap-4 text-sm bg-black/20 p-1 rounded-md">
                        <span>
                          <img className="ui-icon" alt="Удобрение" src={ICONS.fertilizer} />&nbsp;
                          x{inv.items.Fertilizer || 0}
                        </span>
                        <span>
                          <img className="ui-icon" alt="Защита" src={ICONS.protect} />&nbsp;
                          x{inv.items.PestControl || 0}
                        </span>
                      </div>
                  </div>}
                  {activeTab === 'Shop' && <div><h3 className="font-bold mb-1 text-center">Магазин</h3><div className="text-center opacity-80 mb-1">До обновления: {fmtMMSS(Math.ceil((shop.nextRefresh - now)/1000))}</div><div className="grid grid-cols-2 gap-2 mb-2">{Object.entries(CROP_DATA).map(([key, val]) => { const stockInfo = (shop.stock || {})[key] || {available: false, qty: 0}; const canAfford = eco.coins >= val.seedPrice; const inStock = stockInfo.available && stockInfo.qty > 0; return <button key={key} disabled={!canAfford || !inStock} onClick={() => handleBuy('seed', key)} className="text-left p-1 bg-green-700 rounded disabled:opacity-50 flex items-center gap-1"><img className="shop-icon" src={CROP_ICON_URL[key]} alt={val.name} /> <div className="flex-1"><span className="block">{val.name}</span><span className="text-yellow-300">{val.seedPrice}💰</span></div> <span className="text-[10px] bg-black/30 px-1 rounded">{inStock ? `x${stockInfo.qty}`:'Нет'}</span></button>})}</div><strong>Уход:</strong>
                      <div className="flex gap-2 mb-2">
                        <button
                          onClick={() => handleBuy('item', 'Fertilizer')}
                          disabled={eco.coins < 5}
                          className="flex-1 p-1 bg-orange-700 rounded disabled:opacity-50 flex items-center justify-center gap-1">
                          <img className="ui-icon" alt="Удобрение" src={ICONS.fertilizer} />
                          <span>Удобрение (x{inv.items.Fertilizer || 0}) 5💰</span>
                        </button>

                        <button
                          onClick={() => handleBuy('item', 'PestControl')}
                          disabled={eco.coins < 8}
                          className="flex-1 p-1 bg-red-700 rounded disabled:opacity-50 flex items-center justify-center gap-1">
                          <img className="ui-icon" alt="Защита" src={ICONS.protect} />
                          <span>Защита (x{inv.items.PestControl || 0}) 8💰</span>
                        </button>
                      </div>
                  <strong>Улучшения:</strong>{Object.entries(UPGRADE_DATA).map(([key, val]) => { const lvl = upgrades[key] || 0; const cost = val.baseCost + val.costScale * lvl; const isMaxed = key === 'PlotSlots' && gameState.maxPlots >= 16; return <button key={key} disabled={eco.coins < cost || isMaxed} onClick={()=>handleBuy('upgrade', key)} className="w-full p-1 bg-purple-700 rounded mb-1 disabled:opacity-50 text-left">{val.name} (Lvl {lvl})<span className="float-right">{isMaxed ? 'МАКС' : `${cost}💰`}</span></button> })}</div>}
                  {activeTab === 'Orders' && <div><h3 className="font-bold mb-1 text-center">Заказы</h3>{(gameState.orders || []).length === 0 ? <p className="text-center opacity-70">Новые заказы скоро появятся...</p> : (gameState.orders || []).map(order => (<div key={order.id} className="bg-black/20 p-1.5 rounded mb-1"><div>Требуется:{' '}{order.requires.map((r, i) => (<span key={r.item + i}><img className="ui-icon" src={CROP_ICON_URL[r.item]} alt={r.item} /> {CROP_DATA[r.item].name} x{r.qty}{i < order.requires.length - 1 ? ', ' : ''}</span>))}</div><div>Награда: {order.rewardCoins}💰 {order.rewardGems && `${order.rewardGems}💎`}</div><div className="flex justify-between items-center"><span className="opacity-70">Истекает: {formatTime(Math.ceil((order.expiresAt - now)/1000))}</span><button onClick={() => handleFulfillOrder(order)} disabled={lockedOrders[order.id] || !order.requires.every(req => (inv.raw[req.item] || 0) >= req.qty)} className="px-2 py-0.5 bg-green-600 rounded disabled:opacity-50">Сдать</button></div></div>))}</div>}
                  {activeTab === 'Inventory' && <div><h3 className="font-bold mb-1 text-center">Инвентарь и Продажа</h3>{Object.keys(inv.raw).filter(k => (inv.raw[k] || 0) > 0).length === 0 ? <p className="opacity-70 text-center">Соберите урожай, чтобы продать его здесь.</p> : Object.entries(inv.raw).map(([key, val]) => {if (val > 0 && CROP_DATA[key]) { let priceMultiplier = (eco.marketTrend[key] || 1); if(hot?.crop === key) priceMultiplier *= hot.multiplier; return (<div key={key} className="flex items-center justify-between bg-black/20 p-1 rounded mb-1"><span className="flex items-center"><img className="ui-icon mr-1" src={CROP_ICON_URL[key]} alt={key} /> {CROP_DATA[key].name}: {val} {hot?.crop === key ? <span className="text-red-400 font-bold hot-pulse ml-1">HOT</span> : <span className="ml-1 text-gray-300">(x{(eco.marketTrend[key] || 1).toFixed(2)})</span>}</span><div className="flex gap-1"><button onClick={() => handleSell(key, 'one')} className="px-2 bg-red-600 rounded">1</button><button onClick={() => handleSell(key, 'all')} className="px-2 bg-red-800 rounded">Все</button></div></div>)}})}</div>}
              </div>
              <div className="text-center text-xs opacity-60 mt-1">⚡ +{eco.energy.regenPerMinute.toFixed(1)}/мин · Посадка 1⚡ · Полив 1⚡ · Удобрение 2⚡ · Сбор 1⚡</div>
          </div>
        </React.Fragment>
      )
    }

    class ErrorBoundary extends React.Component {
      constructor(p){ super(p); this.state = { hasError:false, err:null }; }
      static getDerivedStateFromError(err){ return { hasError:true, err }; }
      componentDidCatch(err, info){ console.error('UI error:', err, info); }
      render(){
        if (this.state.hasError){
          return React.createElement('div', {style:{padding:'16px'}},
            React.createElement('div', {className:'toast bg-red-600 text-white px-4 py-2 rounded'}, 'Произошла ошибка в интерфейсе. Перезайдите позже.'),
            React.createElement('pre', {style:{whiteSpace:'pre-wrap', opacity:.6, fontSize:'12px'}}, String(this.state.err))
          );
        }
        return this.props.children;
      }
    }
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(
      React.createElement(ErrorBoundary, null, React.createElement(App, null))
    );
  </script>
</body>
</html>

