<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Grow Garden TMA</title>
  
  <!-- Telegram Web App SDK -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  
  <!-- React CDN -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  
  <!-- Babel for JSX in browser -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Tailwind CSS for styling -->
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    :root { color-scheme: light dark; }
    html, body, #root { height: 100%; margin: 0; padding: 0; }
    body {
      background: var(--tg-theme-bg-color, #f1f5f1);
      color: var(--tg-theme-text-color, #000);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      overflow: auto;
    }

    /* –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è */
    .app-container{
      height: 100svh;
      max-width: 540px;
      width: min(100vw, 540px);
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      padding-left: max(12px, env(safe-area-inset-left));
      padding-right: max(12px, env(safe-area-inset-right));
      padding-bottom: env(safe-area-inset-bottom);
      box-sizing: border-box;
    }

    /* –í–µ—Ä—Ö–Ω—è—è –∏–≥—Ä–æ–≤–∞—è –∑–æ–Ω–∞ */
    .play-area{
      position: relative;
      border-radius:16px 16px 24px 24px;
      box-shadow:0 6px 20px rgba(0,0,0,.12);
      padding:12px 14px;
      /* –Ω–µ–±–æ–ª—å—à–æ–π –∑–∞–ø–∞—Å –ø–æ–¥ HUD, –Ω–æ –Ω–µ –≤–ª–∏—è—é—â–∏–π –Ω–∞ –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ —Å–µ—Ç–∫–∏ */
      padding-right: clamp(52px, 12vw, 92px);
      width:100%;
      max-width: 760px;
      margin: 0 auto;
      max-height: clamp(300px, 52svh, 68svh);
      overflow: auto;            /* –≤–∫–ª—é—á–∞–µ–º —Å–∫—Ä–æ–ª–ª –ø–æ–ª—è */
    }

    /* –æ–±—ë—Ä—Ç–∫–∞ –¥–ª—è —Å–µ—Ç–∫–∏ ‚Äî –∏–º–µ–Ω–Ω–æ –Ω–∞ –Ω–µ—ë –∫–ª–∞–¥—ë–º —Å–ª–æ–π –Ω–∞—Å–µ–∫–æ–º—ã—Ö */
    .plots-wrap{
      position: relative;
      width: 100%;
    }

    /* —Å–µ—Ç–∫–∞ –±–µ–∑ vmin ‚Äî —Ç–æ–ª—å–∫–æ px/%, —á—Ç–æ–±—ã –Ω–∞ –ü–ö –Ω–µ —Ä–∞–∑–¥—É–≤–∞–ª–æ */
    .plots{
      --plot-max: 132px;                               /* –ø–æ—Ç–æ–ª–æ–∫ —Ä–∞–∑–º–µ—Ä–∞ –ø–ª–∏—Ç–∫–∏ */
      display: grid;
      gap: clamp(6px, 1.2vw, 12px);
      grid-template-columns: repeat(auto-fill, minmax(96px, var(--plot-max)));
      justify-content: center;
      width: 100%;
      margin: 0 auto;
    }

    @media (min-width:480px){ .plots{ --plot-max: 140px; } }
    @media (min-width:768px){ .plots{ --plot-max: 148px; } }
    
    /* –ö–ª–µ—Ç–∫–∞ –∏ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç—ã ‚Äî –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–µ */
    .plot{
      position:relative;
      aspect-ratio:1/1;
      background-image: url('https://raw.githubusercontent.com/Poklontsevv/growgarden/main/garden_bed%202.png');
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      display:flex;align-items:center;justify-content:center;
      font-size: clamp(12px, 1.4vw, 16px);
    }
    .plot-actions{position:absolute;top:.35em;right:.35em;display:flex;gap:.35em;z-index:10}
    .plot-btn{width:2.2em;height:2.2em;padding:0;font-size:1.1em;border-radius:.6em;background:rgba(0,0,0,.28);color:#fff;display:flex;align-items:center;justify-content:center;border:none}
    .plot-btn:active{transform:scale(.96)}
    .h-1\.5{height:.4em}

    /* –ù–∏–∂–Ω—è—è –ø–∞–Ω–µ–ª—å */
    .bottom-panel{
      height: clamp(220px, 34svh, 320px);
      display:flex; flex-direction:column;
    }
    .panel-scroll{
      flex: 1 1 auto;
      overflow: auto;
      scrollbar-width: thin;
    }
    .panel-scroll::-webkit-scrollbar{ width:4px; }
    .panel-scroll::-webkit-scrollbar-thumb{ background: rgba(0,0,0,.2); border-radius: 2px; }

    .toast{ position: fixed; top: max(8px, calc(env(safe-area-inset-top) + 8px)); left: 50%; transform: translateX(-50%); z-index: 50; }
    .energy-timer{ font-size: 10px; line-height: 1; opacity: .85; }
    
    /* –ê–Ω–∏–º–∞—Ü–∏–∏ */
    @keyframes grow-pop{0%{transform:scale(.7);opacity:0}100%{transform:scale(1);opacity:1}}
    .stage-pop{animation:grow-pop .25s ease-out}
    @keyframes pulse-hot { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); } }
    .hot-pulse { animation: pulse-hot 1.5s ease-in-out infinite; }
    @keyframes heat-pulse { 0%,100%{transform:scale(1)} 50%{transform:scale(1.06)} }
    .heat-pulse{ animation: heat-pulse 1.2s ease-in-out infinite; }
    @keyframes plot-hit { 0%,100%{transform:translateX(0)} 25%{transform:translateX(-2px)} 75%{transform:translateX(2px)} }
    .plot-hit { animation: plot-hit .35s ease; }

    /* –ù–∞—Å–µ–∫–æ–º—ã–µ */
    /* —Å–ª–æ–π –Ω–∞—Å–µ–∫–æ–º—ã—Ö —Ç–µ–ø–µ—Ä—å —Ä–æ–≤–Ω–æ –ø–æ–≤–µ—Ä—Ö —Å–µ—Ç–∫–∏ */
    .bug-layer{
      pointer-events:none;
      position: absolute;
      inset: 0;
      z-index: 5;
    }
    .bug{
      position:absolute;
      font-size:22px;
      filter: drop-shadow(0 1px 2px rgba(0,0,0,.25));
      pointer-events: auto;
      cursor: pointer;
      transition: left 0.3s linear, top 0.3s linear;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useCallback, useMemo } = React;
    
    const tg = window.Telegram?.WebApp;
    if (tg) { tg.ready(); tg.expand(); tg.setHeaderColor('bg_color'); tg.setBackgroundColor('bg_color'); }
    function applyTheme() {
      const p = tg?.themeParams || {};
      document.documentElement.style.setProperty('--tg-theme-bg-color', p.bg_color || '#f1f5f1');
      document.documentElement.style.setProperty('--tg-theme-text-color', p.text_color || '#000000');
    }
    applyTheme();
    tg?.onEvent('themeChanged', applyTheme);
    function haptic(kind) { try { if (!tg?.HapticFeedback) return; if (kind === 'success') tg.HapticFeedback.notificationOccurred('success'); else if (kind === 'error') tg.HapticFeedback.notificationOccurred('error'); else tg.HapticFeedback.impactOccurred('light'); } catch {} }
    const tgUserId = (tg && tg.initDataUnsafe?.user?.id) ? String(tg.initDataUnsafe.user.id) : 'dev';
    const SAVE_KEY = `growGardenState:${tgUserId}`;

    // --- GAME CODE STARTS HERE ---
    const Ticks = { GAME: 1000, WEATHER: 15 * 60 * 1000, MARKET: 5 * 60 * 1000, ORDERS: 10 * 60 * 1000, SHOP: 5 * 60 * 1000, MICRO: 30000, BUG_MOVE: 300 };
    const OFFLINE_CAP_HOURS = 3;
    const clamp = (num, min, max) => Math.min(Math.max(num, min), max);
    const fmtMMSS = (totalSec) => { if (totalSec < 0) totalSec = 0; const m = Math.floor(totalSec / 60); const s = totalSec % 60; return `${m}:${s < 10 ? '0' : ''}${s}`; };
    function formatTime(seconds){
      if (seconds < 0) seconds = 0;
      const m = Math.floor(seconds / 60);
      const s = Math.floor(seconds % 60);
      return `${m}:${s < 10 ? '0' : ''}${s}`;
    }
    function energySecondsToNext(energy, now) { if (energy.current >= energy.max) return 0; const intervalMs = 60000 / Math.max(0.0001, energy.regenPerMinute); const msPassedSinceLastRegen = now - energy.lastRefill; const msLeft = intervalMs - (msPassedSinceLastRegen % intervalMs); return Math.ceil(msLeft / 1000); }
    const stageIcon = (type, stage) => stage === 'Seed' ? 'üå±' : stage === 'Sprout' ? 'üåø' : CROP_DATA[type].icon;
    
    const CROP_DATA = {
        Carrot:    { name: '–ú–æ—Ä–∫–æ–≤—å', icon: 'ü•ï', growTime: 30, basePrice: 4, seedPrice: 5, baseYield: 2, qualityPerTick: 0.003, decayWater: 0.4, decayFert: 0.15, rarity: 'common', stockPerRefresh: 10 },
        Herb:      { name: '–¢—Ä–∞–≤—ã', icon: 'üåø', growTime: 45, basePrice: 5, seedPrice: 6, baseYield: 4, qualityPerTick: 0.002, decayWater: 0.3, decayFert: 0.12, rarity: 'common', stockPerRefresh: 8 },
        Wheat:     { name: '–ü—à–µ–Ω–∏—Ü–∞', icon: 'üåæ', growTime: 50, basePrice: 6, seedPrice: 7, baseYield: 5, qualityPerTick: 0.002, decayWater: 0.35, decayFert: 0.1, rarity: 'common', stockPerRefresh: 8 },
        Potato:    { name: '–ö–∞—Ä—Ç–æ—Ñ–µ–ª—å', icon: 'ü•î', growTime: 70, basePrice: 8, seedPrice: 10, baseYield: 3, qualityPerTick: 0.003, decayWater: 0.4, decayFert: 0.15, rarity: 'common', stockPerRefresh: 6 },
        Tomato:    { name: '–ü–æ–º–∏–¥–æ—Ä', icon: 'üçÖ', growTime: 60, basePrice: 7, seedPrice: 8, baseYield: 3, qualityPerTick: 0.004, decayWater: 0.5, decayFert: 0.18, rarity: 'uncommon', stockPerRefresh: 6 },
        Corn:      { name: '–ö—É–∫—É—Ä—É–∑–∞', icon: 'üåΩ', growTime: 80, basePrice: 10, seedPrice: 12, baseYield: 2, qualityPerTick: 0.004, decayWater: 0.55, decayFert: 0.2, rarity: 'uncommon', stockPerRefresh: 5 },
        Cucumber:  { name: '–û–≥—É—Ä–µ—Ü', icon: 'ü•í', growTime: 75, basePrice: 9, seedPrice: 11, baseYield: 4, qualityPerTick: 0.003, decayWater: 0.6, decayFert: 0.15, rarity: 'uncommon', stockPerRefresh: 5 },
        Onion:     { name: '–õ—É–∫', icon: 'üßÖ', growTime: 65, basePrice: 8, seedPrice: 9, baseYield: 6, qualityPerTick: 0.002, decayWater: 0.4, decayFert: 0.1, rarity: 'uncommon', stockPerRefresh: 7 },
        Sunflower: { name: '–ü–æ–¥—Å–æ–ª–Ω—É—Ö', icon: 'üåª', growTime: 90, basePrice: 12, seedPrice: 15, baseYield: 1, qualityPerTick: 0.005, decayWater: 0.6, decayFert: 0.20, rarity: 'rare', stockPerRefresh: 4 },
        Strawberry:{ name: '–ö–ª—É–±–Ω–∏–∫–∞', icon: 'üçì', growTime: 120, basePrice: 18, seedPrice: 22, baseYield: 5, qualityPerTick: 0.006, decayWater: 0.7, decayFert: 0.25, rarity: 'rare', stockPerRefresh: 3 },
        Pumpkin:   { name: '–¢—ã–∫–≤–∞', icon: 'üéÉ', growTime: 150, basePrice: 25, seedPrice: 30, baseYield: 1, qualityPerTick: 0.007, decayWater: 0.8, decayFert: 0.3, rarity: 'rare', stockPerRefresh: 2 },
        Garlic:    { name: '–ß–µ—Å–Ω–æ–∫', icon: 'üßÑ', growTime: 100, basePrice: 15, seedPrice: 18, baseYield: 8, qualityPerTick: 0.004, decayWater: 0.5, decayFert: 0.15, rarity: 'rare', stockPerRefresh: 4 },
        Blueberry: { name: '–ì–æ–ª—É–±–∏–∫–∞', icon: 'ü´ê', growTime: 240, basePrice: 40, seedPrice: 50, baseYield: 6, qualityPerTick: 0.008, decayWater: 0.9, decayFert: 0.35, rarity: 'epic', stockPerRefresh: 2 },
        Coffee:    { name: '–ö–æ—Ñ–µ', icon: '‚òï', growTime: 300, basePrice: 60, seedPrice: 75, baseYield: 3, qualityPerTick: 0.01, decayWater: 1.0, decayFert: 0.4, rarity: 'epic', stockPerRefresh: 1 },
        Ginseng:   { name: '–ñ–µ–Ω—å—à–µ–Ω—å', icon: 'üå±', growTime: 600, basePrice: 150, seedPrice: 180, baseYield: 1, qualityPerTick: 0.02, decayWater: 1.2, decayFert: 0.5, rarity: 'epic', stockPerRefresh: 1 },
    };
    const UPGRADE_DATA = {
        EnergyCap: { name: '–ú–∞–∫—Å. —ç–Ω–µ—Ä–≥–∏—è', baseCost: 20, costScale: 10, effect: (lvl) => `+5 –ú–∞–∫—Å. ‚ö°` },
        Storage: { name: '–°–∫–ª–∞–¥', baseCost: 25, costScale: 15, effect: (lvl) => `+20 –≤–º–µ—Å—Ç.` },
        EnergyRegen: { name: '–†–µ–≥–µ–Ω. —ç–Ω–µ—Ä–≥–∏–∏', baseCost: 30, costScale: 15, effect: (lvl) => `+0.5 ‚ö°/–º–∏–Ω` },
        PlotSlots: { name: '–î–æ–ø. –≥—Ä—è–¥–∫–∏', baseCost: 50, costScale: 30, effect: (lvl) => `+1 –≥—Ä—è–¥–∫–∞ (–º–∞–∫—Å. 16)` },
    }

    const calculateYield = (crop) => { const d = CROP_DATA[crop.type]; const qMul = 0.8 + 0.4 * (crop.quality - 1); const minY = Math.max(1, Math.round(d.baseYield)); const maxY = Math.max(minY, Math.round(d.baseYield * (1 + qMul))); return Math.floor(Math.random() * (maxY - minY + 1)) + minY; };
    function rollShopStock() { const stock = {}; const now = Date.now(); const weights = { common: 1.0, uncommon: 0.6, rare: 0.3, epic: 0.15 }; Object.entries(CROP_DATA).forEach(([key, d]) => { const appear = Math.random() < (weights[d.rarity] ?? 1); stock[key] = { available: appear, qty: appear ? (d.stockPerRefresh ?? 5) : 0 }; }); return { stock, nextRefresh: now + Ticks.SHOP }; }
    function growthSpeedMul(crop, world, now){ let m = (world.weather==='Sunny'?1:0.9); const red = (crop.water<20 || crop.fertilizer<20) ? 0.5 : 1; m *= red; if (now < crop.waterBoostUntil) m *= 1.25; if (now < crop.fertBoostUntil) m *= 1.15; return m; }
    function secondsToNextStage(crop, world){
      const d = CROP_DATA[crop.type];
      if (!d || crop.progress >= 1) return 0;
      let speedMod = growthSpeedMul(crop, world, Date.now());
      const isBug = (world?.bugs || []).some(b => b.targetPlotId === crop.plotId);
      if (isBug) speedMod *= 0.6;
      const basePerSec = (1 / d.growTime) * speedMod;
      const target = crop.progress < 0.5 ? 0.5 : 1.0;
      const remain = Math.max(0, target - crop.progress);
      const perSec = Math.max(1e-6, basePerSec);
      return Math.ceil(remain / perSec);
    }

    const createInitialState = () => ({
      maxPlots: 6,
      plots: Array.from({ length: 6 }, (_, i) => ({ id: `plot-${i}` })),
      inv: { seeds: Object.fromEntries(Object.keys(CROP_DATA).map(k=>[k,0])), raw:{}, products:{}, items:{Fertilizer:0, PestControl:0} },
      buildings: {}, orders: [],
      eco: { coins: 50, gems: 0, energy: { current: 20, max: 20, lastRefill: Date.now(), regenPerMinute: 1 }, marketTrend: Object.fromEntries(Object.keys(CROP_DATA).map(k=>[k,1])), lastMarketUpdate: Date.now(), hotPrice: null, },
      world: { weather: 'Sunny', event: 'None', lastWeatherUpdate: Date.now(), lastOrdersUpdate: Date.now(), lastMicroTick: Date.now(), heatwaveUntil: 0, bugs: [], bees: [] },
      streak: { day: 0, lastClaim: 0 }, achievements: { }, lastActiveAt: Date.now(),
      upgrades: { EnergyCap: 0, Storage: 0, EnergyRegen: 0, PlotSlots: 0 }, shop: rollShopStock(), quickQuests: [],
    });

    const generateOrders = (count) => { return Array.from({ length: count }, (_, i) => { const reqItem1 = Object.keys(CROP_DATA)[Math.floor(Math.random() * Object.keys(CROP_DATA).length)]; const reqQty1 = 5 + Math.floor(Math.random() * 10); const reward = Math.floor(CROP_DATA[reqItem1].basePrice * reqQty1 * (1.5 + Math.random() * 0.5)); return { id: `order-${Date.now()}-${i}`, requires: [{ item: reqItem1, qty: reqQty1 }], rewardCoins: reward, rewardGems: Math.random() < 0.1 ? 1 : undefined, expiresAt: Date.now() + 15 * 60 * 1000 }; }); };
    
    function App() {
      const [gameState, setGameState] = useState(() => {
        try {
          const saved = localStorage.getItem(SAVE_KEY);
          let state = saved ? JSON.parse(saved) : createInitialState();
          
          state.maxPlots = state.maxPlots ?? 6;
          if (state.plots.length < state.maxPlots) { for (let i = state.plots.length; i < state.maxPlots; i++) { state.plots.push({ id: `plot-${i}` }); } }
          state.shop = state.shop ?? rollShopStock();
          state.upgrades = state.upgrades ?? { EnergyCap: 0, Storage: 0, EnergyRegen: 0, PlotSlots: 0 };
          state.upgrades.PlotSlots = state.upgrades.PlotSlots ?? 0;
          state.inv.seeds = state.inv.seeds ?? {};
          state.inv.items = state.inv.items ?? {Fertilizer:0, PestControl:0};
          state.eco.hotPrice = state.eco.hotPrice ?? null;
          state.quickQuests = state.quickQuests ?? [];
          state.world = state.world ?? {};
          state.world.heatwaveUntil = state.world.heatwaveUntil ?? 0;
          state.world.bugs = state.world.bugs ?? [];
          state.world.bees = state.world.bees ?? [];

          Object.keys(CROP_DATA).forEach(key => {
            if (typeof state.inv.seeds[key] !== 'number') state.inv.seeds[key] = 0;
            if (typeof state.eco.marketTrend[key] !== 'number') state.eco.marketTrend[key] = 1;
          });

          if (!state.orders || state.orders.length === 0) {
            state.orders = generateOrders(3);
            state.world.lastOrdersUpdate = Date.now();
          }

          const now = Date.now();
          const dt = Math.min(now - state.lastActiveAt, OFFLINE_CAP_HOURS * 3600 * 1000);
          const energyGained = Math.floor(dt / 60000 * state.eco.energy.regenPerMinute);
          if (energyGained > 0) { state.eco.energy.current = Math.min(state.eco.energy.max, state.eco.energy.current + energyGained); state.eco.energy.lastRefill = now; }
          state.lastActiveAt = now;
          return state;
        } catch(e) { console.error("Failed to load state, resetting.", e); return createInitialState(); }
      });
      
      const [activeTab, setActiveTab] = useState('Plant');
      const [selectedSeed, setSelectedSeed] = useState('Carrot');
      const [toast, setToast] = useState(null);
      const [now, setNow] = useState(Date.now());
      const [hitPlots, setHitPlots] = useState({});

      useEffect(() => { localStorage.setItem(SAVE_KEY, JSON.stringify(gameState)); }, [gameState]);

      const showToast = useCallback((message, isError = false) => { setToast(message); if (isError) haptic('error'); setTimeout(() => setToast(null), 3000); }, []);

      useEffect(() => {
        const gameTimer = setInterval(() => {
            const currentTime = Date.now();
            setNow(currentTime);

            setGameState(prev => {
                const newState = JSON.parse(JSON.stringify(prev));
                const dtSec = (currentTime - (newState.lastActiveAt || currentTime)) / 1000;
                
                if ((newState.shop?.nextRefresh ?? 0) <= currentTime) newState.shop = rollShopStock();
                if ((newState.eco.hotPrice?.endsAt ?? 0) <= currentTime) newState.eco.hotPrice = null;
                if (newState.world.heatwaveUntil && newState.world.heatwaveUntil <= currentTime) newState.world.heatwaveUntil = 0;
                
                const energyDt = currentTime - newState.eco.energy.lastRefill;
                const energyGained = Math.floor(energyDt / 60000 * newState.eco.energy.regenPerMinute);
                if (energyGained > 0) { newState.eco.energy.current = Math.min(newState.eco.energy.max, newState.eco.energy.current + energyGained); newState.eco.energy.lastRefill += energyGained * (60000 / newState.eco.energy.regenPerMinute); }

                if (currentTime - (newState.world.lastOrdersUpdate || 0) >= Ticks.ORDERS) {
                  newState.orders = (newState.orders || []).filter(o => o.expiresAt > currentTime);
                  const need = Math.max(0, 3 - newState.orders.length);
                  if (need > 0) newState.orders.push(...generateOrders(need));
                  newState.world.lastOrdersUpdate = currentTime;
                } else {
                  // –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ —á–∏—Å—Ç–∏–º –∏—Å—Ç—ë–∫—à–∏–µ –∫–∞–∂–¥—ã–π —Ç–∏–∫
                  newState.orders = (newState.orders || []).filter(o => o.expiresAt > currentTime);
                }

                if (currentTime - (newState.world.lastWeatherUpdate || 0) >= Ticks.WEATHER) {
                    newState.world.weather = ['Sunny', 'Rainy', 'Cloudy'][Math.floor(Math.random() * 3)];
                    newState.world.lastWeatherUpdate = currentTime;
                    if (newState.world.weather === 'Sunny' && Math.random() < 0.35) { newState.world.heatwaveUntil = currentTime + (90 + Math.random() * 90) * 1000; }
                }

                if (currentTime - (newState.world.lastMicroTick || 0) >= Ticks.MICRO) {
                    const activePlots = newState.plots.filter(p => p.crop);
                    if (activePlots.length > 0) {
                      if (Math.random() < 0.14 && newState.world.bugs.length < 8) {
                        const target = activePlots[Math.floor(Math.random() * activePlots.length)];
                        // —Å—Ç–∞—Ä—Ç –≤–Ω—É—Ç—Ä–∏ –ø–æ–ª—è, –Ω–æ –±–ª–∏–∑–∫–æ –∫ –∫—Ä–∞—è–º
                        const startX = 2 + Math.random() * 96;   // 2..98%
                        const startY = 4 + Math.random() * 92;   // 4..96%

                        newState.world.bugs.push({
                          id:`bug-${currentTime}-${Math.random()}`,
                          type:'bug',
                          x:startX, y:startY,
                          dir: Math.random()<0.5 ? 'left' : 'right',
                          speed: 18 + Math.random()*24,
                          expiresAt: currentTime+30000,
                          targetPlotId: target.id
                        });
                      }
                      if (Math.random() < 0.18 && newState.world.bees.length < 10) {
                        const target = activePlots[Math.floor(Math.random() * activePlots.length)];
                        // –ø—á—ë–ª –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ:
                        const startX = 2 + Math.random() * 96;
                        const startY = 4 + Math.random() * 92;
                        newState.world.bees.push({
                          id:`bee-${currentTime}-${Math.random()}`,
                          type:'bee',
                          x:startX, y:startY,
                          dir: Math.random()<0.5 ? 'left' : 'right',
                          speed: 26 + Math.random()*30,
                          expiresAt: currentTime+25000,
                          targetPlotId: target.id
                        });
                      }
                    }
                    newState.world.lastMicroTick = currentTime;
                }
                
                const heatMul = newState.world.heatwaveUntil > currentTime ? 2.25 : 1.0;
                const newHitPlots = {};
                newState.plots.forEach((plot) => {
                    if (plot.crop) {
                        const cropData = CROP_DATA[plot.crop.type];
                        const isBug = (newState.world.bugs || []).some(b=>b.targetPlotId===plot.id);
                        const isBee = (newState.world.bees || []).some(b=>b.targetPlotId===plot.id);
                        if (isBug) newHitPlots[plot.id] = true;

                        let growthSpeedModifier = growthSpeedMul(plot.crop, newState.world, currentTime);
                        let waterDecayMul = heatMul; let fertDecayMul = 1.0;
                        const shieldModifier = (plot.crop.shieldUntil && currentTime < plot.crop.shieldUntil) ? 0.5 : 1.0;

                        if (isBug){ growthSpeedModifier *= 0.6; waterDecayMul*=1.35; fertDecayMul*=1.25; plot.crop.quality = clamp(plot.crop.quality - 0.006*dtSec, 0.8, 2); }
                        if (isBee){ growthSpeedModifier *= 0.8; waterDecayMul*=1.15; fertDecayMul*=1.10; }

                        if (plot.crop.progress < 1) {
                            const speed = growthSpeedModifier;
                            plot.crop.progress = clamp(plot.crop.progress + dtSec / cropData.growTime * speed, 0, 1);
                            plot.crop.stage = plot.crop.progress >= 0.5 ? 'Sprout' : 'Seed';
                        } else {
                            if (plot.crop.stage !== 'Mature') { plot.crop.stage = 'Mature'; plot.crop.harvestYield = calculateYield(plot.crop); }
                        }
                    }
                });
                
                const moveInsects = (insects, dt) => insects.map(i => {
                  let newX = i.x + (i.dir === 'left' ? -i.speed*dt : i.speed*dt);
                  let newY = i.y + (Math.random() - .5) * 1.5;

                  if (newX > 100) { newX = 100; i.dir = 'left'; }
                  if (newX < 0)   { newX = 0;   i.dir = 'right'; }
                  if (newY > 98) newY = 98;
                  if (newY < 2)  newY = 2;

                  return { ...i, x:newX, y:newY };
                }).filter(i => i && i.expiresAt > currentTime);
                
                newState.world.bugs = moveInsects(newState.world.bugs, dtSec / 60);
                newState.world.bees = moveInsects(newState.world.bees, dtSec / 60);
                
                if (Object.keys(newHitPlots).length > 0) { setTimeout(() => setHitPlots(newHitPlots), 0); setTimeout(() => setHitPlots({}), 350); }
                newState.lastActiveAt = currentTime;
                return newState;
            });
        }, Ticks.GAME);
        return () => clearInterval(gameTimer);
      }, []);

      const spendEnergy = (amount) => { if (gameState.eco.energy.current < amount) { showToast("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —ç–Ω–µ—Ä–≥–∏–∏! ‚ö°", true); return false; } setGameState(prev => ({ ...prev, eco: { ...prev.eco, energy: { ...prev.eco.energy, current: prev.eco.energy.current - amount } } })); return true; }
      const handlePlotClick = (plot) => { if (plot.crop?.stage === 'Mature') handleHarvest(plot.id); else if (!plot.crop) handlePlant(plot.id); }
      const handleInsectClick = (kind, id) => { if (!spendEnergy(1)) return; haptic('success'); setGameState(prev=>{ const ns={...prev}; if (kind==='bug') ns.world.bugs = ns.world.bugs.filter(b=>b.id!==id); else ns.world.bees = ns.world.bees.filter(b=>b.id!==id); ns.eco.coins += (kind==='bug'?5:3); return ns; }); showToast(kind==='bug'?'üêõ —É–Ω–∏—á—Ç–æ–∂–µ–Ω–∞!': 'üêù –ø—Ä–æ–≥–Ω–∞–Ω—ã!'); }

      const handlePlant = (plotId) => {
        const seedType = selectedSeed;
        if ((gameState.inv.seeds[seedType] || 0) < 1) { showToast(`–ö—É–ø–∏—Ç–µ —Å–µ–º–µ–Ω–∞ ${CROP_DATA[seedType].name} –≤ Shop`, true); return; }
        if (!spendEnergy(1)) return;
        haptic('success');
        setGameState(prev=>{
          const idx = prev.plots.findIndex(p=>p.id===plotId);
          if (idx<0 || prev.plots[idx].crop) return prev;
          const next = JSON.parse(JSON.stringify(prev));
          next.plots[idx].crop = { type: seedType, plantedAt: Date.now(), stage:'Seed', progress:0, water: 45 + Math.floor(Math.random()*15), fertilizer: 40 + Math.floor(Math.random()*15), quality:1.0, plotId, waterBoostUntil:0, fertBoostUntil:0 };
          next.inv.seeds[seedType] = Math.max(0, (next.inv.seeds[seedType]||0) - 1);
          return next;
        });
      };

      const handleHarvest = (plotId) => {
          const plot = gameState.plots.find(p => p.id === plotId);
          if (!plot?.crop || plot.crop.stage !== 'Mature' || !spendEnergy(1)) return;
          let baseYield = plot.crop.harvestYield ?? calculateYield(plot.crop);
          const bonus = (plot.crop.shieldUntil && now < plot.crop.shieldUntil) ? Math.floor(baseYield * 0.1) : 0;
          const yieldCount = baseYield + bonus;
          haptic('success');
          setGameState(prev => ({...prev, plots: prev.plots.map(p => p.id === plotId ? { ...p, crop: undefined } : p), inv: {...prev.inv, raw: {...prev.inv.raw, [plot.crop.type]: (prev.inv.raw[plot.crop.type] || 0) + yieldCount }}, }));
          showToast(`–°–æ–±—Ä–∞–Ω–æ ${CROP_DATA[plot.crop.type].name} x${yieldCount}`);
      }

      const handleCareFor = (plotId, action) => {
          if (action === 'water') {
            if(!spendEnergy(1)) return; haptic('light');
            setGameState(prev => ({...prev, plots: prev.plots.map(p => (p.id===plotId && p.crop) ? {...p, crop:{...p.crop, water: clamp(p.crop.water+25,0,100), lastWateredAt: Date.now(), waterBoostUntil: Date.now() + 15000 }} : p)}));
          } else if (action === 'fertilize') {
            if ((gameState.inv.items.Fertilizer || 0) < 1) { showToast("–ù–µ—Ç —É–¥–æ–±—Ä–µ–Ω–∏–π", true); return; }
            if (!spendEnergy(2)) return; haptic('light');
            setGameState(prev => ({...prev, plots: prev.plots.map(p => (p.id===plotId && p.crop) ? {...p, crop:{...p.crop, fertilizer: clamp(p.crop.fertilizer+25,0,100), lastFertilizedAt: Date.now(), fertBoostUntil: Date.now() + 15000 }} : p), inv: {...prev.inv, items: {...prev.inv.items, Fertilizer: prev.inv.items.Fertilizer - 1}}}));
          } else if (action === 'shield') {
            if ((gameState.inv.items.PestControl || 0) < 1) { showToast("–ù–µ—Ç –∑–∞—â–∏—Ç—ã", true); return; }
            if (!spendEnergy(1)) return; haptic('light');
            setGameState(prev => ({...prev, plots: prev.plots.map(p => (p.id === plotId && p.crop) ? {...p, crop: {...p.crop, shieldUntil: Date.now() + 10 * 60 * 1000 }} : p), inv: {...prev.inv, items: {...prev.inv.items, PestControl: prev.inv.items.PestControl - 1}}}));
          } 
      }

      const handleBuy = (type, key) => {
        const level = gameState.upgrades[key] || 0;
        const cost =
          type === 'seed' ? CROP_DATA[key].seedPrice
          : type === 'item' ? (key === 'Fertilizer' ? 5 : 8)
          : UPGRADE_DATA[key].baseCost + UPGRADE_DATA[key].costScale * level;

        if (gameState.eco.coins < cost) { showToast("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–æ–Ω–µ—Ç!", true); return; }

        if (type === 'seed') {
          const stockInfo = (gameState.shop?.stock || {})[key] || {available:false, qty:0};
          if (!stockInfo.available || stockInfo.qty <= 0) { showToast('–ù–µ—Ç –≤ –ø—Ä–æ–¥–∞–∂–µ', true); return; }
        }

        haptic('success');
        setGameState(prev => {
          const ns = JSON.parse(JSON.stringify(prev));
          ns.eco.coins -= cost;

          if (type === 'seed') {
            const s = ns.shop.stock[key];
            s.qty = Math.max(0, (s.qty || 0) - 1);
            if (s.qty === 0) s.available = false;
            ns.inv.seeds[key] = (ns.inv.seeds[key] || 0) + 1;
          } else if (type === 'item') {
            ns.inv.items[key] = (ns.inv.items[key] || 0) + 1;
          } else if (type === 'upgrade') {
            ns.upgrades[key] = (ns.upgrades[key] || 0) + 1;
            if (key === 'EnergyCap') ns.eco.energy.max += 5;
            else if (key === 'EnergyRegen') ns.eco.energy.regenPerMinute += 0.5;
            else if (key === 'PlotSlots' && ns.maxPlots < 16) {
              ns.maxPlots += 1;
              ns.plots.push({ id: `plot-${ns.plots.length}` });
            }
            // Storage –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Å–µ–π—á–∞—Å ‚Äî –Ω–µ —Ç—Ä–æ–≥–∞–µ–º —Å–∫–ª–∞–¥, —á—Ç–æ–±—ã –Ω–µ —É–ø–∞—Å—Ç—å.
          }

          return ns; // <-- –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –Ω–æ–≤–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        });
        showToast("–ü–æ–∫—É–ø–∫–∞ —Å–æ–≤–µ—Ä—à–µ–Ω–∞!");
      };

      const handleSell = (item, amount) => {
          const have = gameState.inv.raw[item] || 0;
          const qty = amount === 'one' ? 1 : have;
          if (qty <= 0) return;
          let priceMultiplier = gameState.eco.marketTrend[item] || 1;
          if(gameState.eco.hotPrice?.crop === item) { priceMultiplier *= gameState.eco.hotPrice.multiplier; }
          const price = Math.max(0, Math.floor(CROP_DATA[item].basePrice * priceMultiplier));
          haptic('success');
          setGameState(prev => ({...prev, eco: {...prev.eco, coins: prev.eco.coins + (price * qty)}, inv: {...prev.inv, raw: {...prev.inv.raw, [item]: have - qty}} }));
          showToast(`–ü—Ä–æ–¥–∞–Ω–æ –Ω–∞ ${price * qty}üí∞`);
      }
      
      const handleFulfillOrder = (order) => {
        if (!order.requires.every(req => (gameState.inv.raw[req.item] || 0) >= req.qty)) { showToast("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Ä–µ—Å—É—Ä—Å–æ–≤!", true); return; }
        haptic('success');
        setGameState(prev=>{ const ns = JSON.parse(JSON.stringify(prev)); order.requires.forEach(req => { ns.inv.raw[req.item] -= req.qty; }); ns.eco.coins += order.rewardCoins; if (order.rewardGems) ns.eco.gems += order.rewardGems; ns.orders = ns.orders.filter(o=>o.id!==order.id); return ns; });
        showToast(`–ó–∞–∫–∞–∑ –≤—ã–ø–æ–ª–Ω–µ–Ω! +${order.rewardCoins}üí∞`);
      };
      
      const { eco, inv, plots, world, shop, upgrades } = gameState;
      const hot = eco.hotPrice;

      return (
        <div className="app-container text-gray-800 font-sans">
            {toast && <div className="toast bg-blue-500 text-white px-6 py-2 rounded-full shadow-lg animate-bounce">{toast}</div>}
            
            <div className="play-area bg-green-400 flex-[2] relative">
                <div className="absolute top-2 right-2 flex flex-col items-end gap-1 text-sm z-10">
                    <div className="bg-yellow-400 text-yellow-900 font-bold px-3 py-1 rounded-full shadow-md">üí∞ {eco.coins}</div>
                    <div className="bg-purple-400 text-purple-900 font-bold px-3 py-1 rounded-full shadow-md">üíé {eco.gems}</div>
                    <div className="bg-blue-300 text-blue-900 font-bold px-3 py-1 rounded-full shadow-md leading-tight flex flex-col items-end">
                      <span>‚ö° {eco.energy.current}/{eco.energy.max}</span>
                      <span className="energy-timer">{eco.energy.current >= eco.energy.max ? 'Full' : `+1 in ${fmtMMSS(energySecondsToNext(eco.energy, now))}`}</span>
                    </div>
                </div>
                
                {hot && <div className="absolute top-2 left-2 text-center bg-red-500 text-white p-1 rounded-lg shadow-lg"><span className="hot-pulse text-lg">üî•</span><span className="block text-xs font-bold">HOT: {CROP_DATA[hot.crop].icon} x{hot.multiplier.toFixed(2)}</span><span className="block text-[10px] opacity-80">{fmtMMSS((hot.endsAt - now)/1000)}</span></div>}
                {world.heatwaveUntil > now && <div className="absolute top-2 left-2 translate-x-[84px] text-center bg-orange-500 text-white p-1 rounded-lg shadow-lg heat-pulse"><span className="text-lg">‚òÄÔ∏è</span><span className="block text-xs font-bold">HEAT x2.25</span><span className="block text-[10px] opacity-90">{fmtMMSS((world.heatwaveUntil - now)/1000)}</span></div>}

                <div className="plots-wrap">
                  <div className="bug-layer">
                    {[...(world.bugs || []), ...(world.bees || [])].map(ent=>(
                      <span
                        key={ent.id}
                        className="bug"
                        style={{ left:`${ent.x}%`, top:`${ent.y}%` }}
                        onClick={(e)=>{ e.stopPropagation(); handleInsectClick(ent.type, ent.id); }}
                      >{ent.type==='bug'?'üêõ':'üêù'}</span>
                    ))}
                  </div>

                  <div className="plots">
                      {plots.map(plot => {
                          const isBug = (world.bugs || []).some(b => b.targetPlotId === plot.id);
                          const isBee = (world.bees || []).some(b => b.targetPlotId === plot.id);
                          return (
                          <div key={plot.id} onClick={() => handlePlotClick(plot)} className={`plot cursor-pointer transition-all duration-200 ${hitPlots[plot.id] ? 'plot-hit' : ''}`}>
                              {plot.crop ? (<>
                                  {plot.crop.shieldUntil && now < plot.crop.shieldUntil && <span className="absolute top-1 left-1 text-base">üõ°Ô∏è</span>}
                                  {isBug && <span className="absolute -top-1 right-1 text-sm">-üêõ</span>}
                                  {isBee && <span className="absolute -top-1 right-6 text-sm">-üêù</span>}
                                  <div className="plot-actions"><button onClick={(e) => { e.stopPropagation(); handleCareFor(plot.id, 'water'); }} className="plot-btn" title="–ü–æ–ª–∏—Ç—å 1‚ö°">üíß</button><button onClick={(e) => { e.stopPropagation(); handleCareFor(plot.id, 'fertilize'); }} className="plot-btn" title="–£–¥–æ–±—Ä–∏—Ç—å 2‚ö°">üåø</button><button onClick={(e) => { e.stopPropagation(); handleCareFor(plot.id, 'shield'); }} className="plot-btn" title="–ó–∞—â–∏—Ç–∞ 1‚ö°">üõ°Ô∏è</button></div>
                                  <div className={`text-[2.4em] md:text-[2.8em] ${plot.crop.stage !== plot.prevStage ? 'stage-pop' : ''}`}>{stageIcon(plot.crop.type, plot.crop.stage)}</div>
                                  {plot.crop.stage === 'Mature' ? ( <> <div className="text-xs font-bold text-green-300">x{plot.crop.harvestYield ?? calculateYield(plot.crop)}</div> <div className="absolute inset-x-0 bottom-6 text-center"><span className="inline-block text-[11px] px-2 py-0.5 rounded-full bg-black/35 text-white">Tap to harvest</span></div> </> ) : ( <div className="text-[.78em] text-white bg-black/35 rounded-full px-2 py-0.5 -mt-1 flex items-center gap-1"><span>{plot.crop.stage}</span><span className="opacity-90">‚Ä¢</span><span>{fmtMMSS(secondsToNextStage(plot.crop, world))}</span></div> )}
                                  <div className="absolute bottom-1 left-1 right-1 flex flex-col gap-0.5"><div className="h-1.5 bg-black/20 rounded-full"><div style={{width: `${plot.crop.water}%`}} className="h-full bg-blue-400 rounded-full"></div></div><div className="h-1.5 bg-black/20 rounded-full"><div style={{width: `${plot.crop.fertilizer}%`}} className="h-full bg-orange-400 rounded-full"></div></div></div>
                              </>) : <div className="text-gray-400 text-xs text-center">–ü—É—Å—Ç–æ</div>}
                          </div>
                      )})}
                  </div>
                </div>
            </div>
            <div className="bottom-panel bg-yellow-800/90 w-full p-2 text-white">
                <div className="flex justify-center gap-1 mb-2">{(['Plant', 'Shop', 'Orders', 'Inventory']).map(tab => <button key={tab} onClick={() => setActiveTab(tab)} className={`px-2 py-1 text-xs rounded-t-lg ${activeTab === tab ? 'bg-yellow-600 font-bold' : 'bg-yellow-900'}`}>{tab}</button>)}</div>
                <div className="panel-scroll bg-yellow-600 rounded-lg p-2 text-xs">
                    {activeTab === 'Plant' && <div><h3 className="text-center font-bold mb-1">–ü–æ—Å–∞–¥–∫–∞</h3><div className="grid grid-cols-4 sm:grid-cols-5 gap-1 bg-black/20 p-1 rounded-md mb-2">{Object.entries(CROP_DATA).map(([key, c]) => (<button key={key} onClick={() => setSelectedSeed(key)} className={`p-1 rounded text-center ${selectedSeed === key ? 'bg-green-500' : ''}`} title={`${c.name} (—É –≤–∞—Å: ${inv.seeds[key] || 0})`}><span className="text-2xl">{c.icon}</span><span className="block text-[10px]">x{inv.seeds[key] || 0}</span></button>))}</div><div className="flex justify-center gap-4 text-sm bg-black/20 p-1 rounded-md"><span>üåø x{inv.items.Fertilizer || 0}</span><span>üõ°Ô∏è x{inv.items.PestControl || 0}</span></div></div>}
                    {activeTab === 'Shop' && <div><h3 className="font-bold mb-1 text-center">–ú–∞–≥–∞–∑–∏–Ω</h3><div className="text-center opacity-80 mb-1">–î–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è: {fmtMMSS(Math.ceil((shop.nextRefresh - now)/1000))}</div><div className="grid grid-cols-2 gap-2 mb-2">{Object.entries(CROP_DATA).map(([key, val]) => { const stockInfo = (shop.stock || {})[key] || {available: false, qty: 0}; const canAfford = eco.coins >= val.seedPrice; const inStock = stockInfo.available && stockInfo.qty > 0; return <button key={key} disabled={!canAfford || !inStock} onClick={() => handleBuy('seed', key)} className="text-left p-1 bg-green-700 rounded disabled:opacity-50 flex items-center gap-1">{val.icon} <div className="flex-1"><span className="block">{val.name}</span><span className="text-yellow-300">{val.seedPrice}üí∞</span></div> <span className="text-[10px] bg-black/30 px-1 rounded">{inStock ? `x${stockInfo.qty}`:'–ù–µ—Ç'}</span></button>})}</div><strong>–£—Ö–æ–¥:</strong><div className="flex gap-2 mb-2"><button onClick={() => handleBuy('item', 'Fertilizer')} disabled={eco.coins < 5} className="flex-1 p-1 bg-orange-700 rounded disabled:opacity-50">–£–¥–æ–±—Ä–µ–Ω–∏–µ (x{inv.items.Fertilizer || 0}) 5üí∞</button><button onClick={() => handleBuy('item', 'PestControl')} disabled={eco.coins < 8} className="flex-1 p-1 bg-red-700 rounded disabled:opacity-50">–ó–∞—â–∏—Ç–∞ (x{inv.items.PestControl || 0}) 8üí∞</button></div><strong>–£–ª—É—á—à–µ–Ω–∏—è:</strong>{Object.entries(UPGRADE_DATA).map(([key, val]) => { const lvl = upgrades[key] || 0; const cost = val.baseCost + val.costScale * lvl; const isMaxed = key === 'PlotSlots' && gameState.maxPlots >= 16; return <button key={key} disabled={eco.coins < cost || isMaxed} onClick={()=>handleBuy('upgrade', key)} className="w-full p-1 bg-purple-700 rounded mb-1 disabled:opacity-50 text-left">{val.name} (Lvl {lvl})<span className="float-right">{isMaxed ? '–ú–ê–ö–°' : `${cost}üí∞`}</span></button> })}</div>}
                    {activeTab === 'Orders' && <div><h3 className="font-bold mb-1 text-center">–ó–∞–∫–∞–∑—ã</h3>{(gameState.orders || []).length === 0 ? <p className="text-center opacity-70">–ù–æ–≤—ã–µ –∑–∞–∫–∞–∑—ã —Å–∫–æ—Ä–æ –ø–æ—è–≤—è—Ç—Å—è...</p> : (gameState.orders || []).map(order => (<div key={order.id} className="bg-black/20 p-1.5 rounded mb-1"><div>–¢—Ä–µ–±—É–µ—Ç—Å—è: {order.requires.map(r => `${CROP_DATA[r.item]?.icon || ''} ${r.item} x${r.qty}`).join(', ')}</div><div>–ù–∞–≥—Ä–∞–¥–∞: {order.rewardCoins}üí∞ {order.rewardGems && `${order.rewardGems}üíé`}</div><div className="flex justify-between items-center"><span className="opacity-70">–ò—Å—Ç–µ–∫–∞–µ—Ç: {formatTime(Math.ceil((order.expiresAt - now)/1000))}</span><button onClick={() => handleFulfillOrder(order)} disabled={!order.requires.every(req => (inv.raw[req.item] || 0) >= req.qty)} className="px-2 py-0.5 bg-green-600 rounded disabled:opacity-50">–°–¥–∞—Ç—å</button></div></div>))}</div>}
                    {activeTab === 'Inventory' && <div><h3 className="font-bold mb-1 text-center">–ò–Ω–≤–µ–Ω—Ç–∞—Ä—å –∏ –ü—Ä–æ–¥–∞–∂–∞</h3>{Object.keys(inv.raw).filter(k => (inv.raw[k] || 0) > 0).length === 0 ? <p className="opacity-70 text-center">–°–æ–±–µ—Ä–∏—Ç–µ —É—Ä–æ–∂–∞–π, —á—Ç–æ–±—ã –ø—Ä–æ–¥–∞—Ç—å –µ–≥–æ –∑–¥–µ—Å—å.</p> : Object.entries(inv.raw).map(([key, val]) => {if (val > 0 && CROP_DATA[key]) { let priceMultiplier = (eco.marketTrend[key] || 1); if(hot?.crop === key) priceMultiplier *= hot.multiplier; return (<div key={key} className="flex items-center justify-between bg-black/20 p-1 rounded mb-1"><span>{CROP_DATA[key].icon} {key}: {val} {hot?.crop === key ? <span className="text-red-400 font-bold hot-pulse">HOT</span> : `(x${(eco.marketTrend[key] || 1).toFixed(2)})`}</span><div className="flex gap-1"><button onClick={() => handleSell(key, 'one')} className="px-2 bg-red-600 rounded">1</button><button onClick={() => handleSell(key, 'all')} className="px-2 bg-red-800 rounded">–í—Å–µ</button></div></div>)}})}</div>}
                </div>
                <div className="text-center text-xs opacity-60 mt-1">‚ö° +{eco.energy.regenPerMinute.toFixed(1)}/–º–∏–Ω ¬∑ –ü–æ—Å–∞–¥–∫–∞ 1‚ö° ¬∑ –ü–æ–ª–∏–≤ 1‚ö° ¬∑ –£–¥–æ–±—Ä–µ–Ω–∏–µ 2‚ö° ¬∑ –°–±–æ—Ä 1‚ö°</div>
            </div>
        </div>
      )
    }

    class ErrorBoundary extends React.Component {
      constructor(p){ super(p); this.state = { hasError:false, err:null }; }
      static getDerivedStateFromError(err){ return { hasError:true, err }; }
      componentDidCatch(err, info){ console.error('UI error:', err, info); }
      render(){
        if (this.state.hasError){
          return React.createElement('div', {style:{padding:'16px'}},
            React.createElement('div', {className:'toast bg-red-600 text-white px-4 py-2 rounded'}, '–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –≤ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ. –ü–µ—Ä–µ–∑–∞–π–¥–∏—Ç–µ –ø–æ–∑–∂–µ.'),
            React.createElement('pre', {style:{whiteSpace:'pre-wrap', opacity:.6, fontSize:'12px'}}, String(this.state.err))
          );
        }
        return this.props.children;
      }
    }
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(
      React.createElement(ErrorBoundary, null, React.createElement(App, null))
    );
  </script>
</body>
</html>

